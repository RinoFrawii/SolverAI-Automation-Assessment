{
  "name": "SolverAI Assessment",
  "nodes": [
    {
      "parameters": {
        "updates": [
          "messages"
        ],
        "options": {}
      },
      "type": "n8n-nodes-base.whatsAppTrigger",
      "typeVersion": 1,
      "position": [
        -624,
        544
      ],
      "id": "b175d045-f573-4703-9d2d-1ef6cf4b8082",
      "name": "WhatsApp Trigger",
      "webhookId": "864acdea-2d58-4fea-acf0-580392677c20",
      "credentials": {
        "whatsAppTriggerApi": {
          "id": "wPdg5B9P3UsCrrGs",
          "name": "WhatsApp OAuth account"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "// @ts-nocheck\n// Extract & Classify (WhatsApp + Email) with binary preservation\n\nconst item   = $input.item;            // full item (json + binary)\nconst json   = item.json || {};\nconst binary = item.binary || {};\n\nconst isWhatsApp = !!(json?.entry?.[0]?.changes?.[0]?.value?.messages || json?.messages);\nconst isEmail    = !!(json?.headers || json?.subject || json?.from || Object.keys(binary||{}).length);\n\n// ---------- WhatsApp NORMALIZATION ----------\nlet wa_from = '', wa_text = '', is_command = false, is_document = false, media = null, channel = '';\n\nif (isWhatsApp) {\n  channel = 'whatsapp';\n\n  const value = json?.entry?.[0]?.changes?.[0]?.value || json;\n  const msg   = value?.messages?.[0] || {};\n  const type  = String(msg.type || '').toLowerCase();\n\n  // sender\n  wa_from = String(msg.from || value?.contacts?.[0]?.wa_id || '').replace(/[^\\d]/g, '');\n\n  // payloads\n  const textBody = (msg.text?.body || '').trim();\n  const doc = msg.document || null;\n  const img = msg.image || null;\n\n  const docInfo = doc ? {\n    media_type: 'document',\n    id: doc.id || '',\n    filename: doc.filename || '',\n    mime_type: doc.mime_type || '',\n    sha256: doc.sha256 || ''\n  } : null;\n\n  const imgInfo = img ? {\n    media_type: 'image',\n    id: img.id || '',\n    filename: '',                      // WA image may not include a filename\n    mime_type: img.mime_type || '',\n    sha256: img.sha256 || '',\n    caption: (img.caption || '').trim()\n  } : null;\n\n  // wa_text\n  if (type === 'text') wa_text = textBody;\n  else if (type === 'document') wa_text = docInfo?.filename || docInfo?.id || '';\n  else if (type === 'image') wa_text = imgInfo?.caption || imgInfo?.id || '';\n\n  // classify\n  const isText = type === 'text';\n  const approvers = new Set(['601123368808']); // digits only; adjust to your approver(s)\n  const isApprover = approvers.size ? approvers.has(wa_from) : true;\n  is_command = isText && isApprover && /^(APPROVE|REJECT|CORRECT)\\b/i.test(textBody);\n\n  is_document = (type === 'document' || type === 'image');\n  media = docInfo || imgInfo || null;\n\n  // return (no binary from WA here)\n  return [{\n    json: {\n      channel,\n      wa_text,\n      wa_from,\n      is_command,\n      is_document,\n      media,\n      raw: value\n    }\n  }];\n}\n\n// ---------- EMAIL NORMALIZATION ----------\nif (isEmail) {\n  channel = 'email';\n\n  // find the first binary attachment key (prefer 'file' if present)\n  const binKeys = Object.keys(binary || {});\n  let binary_key = binKeys.includes('file') ? 'file' : (binKeys[0] || null);\n  const b = binary_key ? binary[binary_key] : null;\n\n  // best-effort filename/mime from binary or json\n  const filename = (b?.fileName || json?.attachment_name || json?.filename || '').toString();\n  const mime_type = (b?.mimeType || json?.attachment_mime || json?.mime_type || '').toString();\n\n  // email body/subject (useful when there is no attachment caption)\n  const subject = (json.subject || json.headers?.subject || '').toString();\n  const textPlain = (json.textPlain || json.text || '').toString();\n\n  wa_text = filename || subject || ''; // what your flow expects to show\n  wa_from = (json.from?.address || json.from || '').toString();\n\n  // Build media if we have an attachment\n  is_document = !!b; // treat email attachment as document\n  media = b ? {\n    media_type: mime_type?.startsWith('image/') ? 'image' : 'document',\n    id: '',                 // not needed for email (we already have the binary)\n    filename,\n    mime_type\n  } : null;\n\n  // Not an approval command (email body could include words like approve; we ignore)\n  is_command = false;\n\n  // IMPORTANT: preserve the binary so downstream extractors can read it\n  return [{\n    json: {\n      channel,\n      wa_text,\n      wa_from,\n      is_command,\n      is_document,\n      media,\n      binary_key,        // which binary prop holds the file (usually 'file')\n      subject,\n      text_body: textPlain\n    },\n    binary              // pass through untouched\n  }];\n}\n\n// Fallback: nothing we recognize\nreturn [{ json: { channel: 'unknown', is_command: false, is_document: false, wa_text: '', wa_from: '' } }];\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -400,
        448
      ],
      "id": "5f5f0428-9424-49a9-a789-8a35911c6266",
      "name": "Extract & Classify"
    },
    {
      "parameters": {
        "mode": "runOnceForEachItem",
        "jsCode": "// @ts-nocheck\nconst raw = String($json.wa_text || '').trim();\nconst from = String($json.wa_from || '').replace(/[^\\d]/g,'');\n\n// ---------- helpers ----------\nconst aliasMap = new Map(Object.entries({\n  // doc number (added suggestion C aliases)\n  'doc_number':'doc_number','_number':'doc_number','number':'doc_number',\n  'docno':'doc_number','doc_no':'doc_number','doc-id':'doc_number','docid':'doc_number',\n  'invoice_no':'doc_number','invoice_no.':'doc_number','invoice_number':'doc_number',\n  'invoiceid':'doc_number','invoice_id':'doc_number','invoice':'doc_number',\n  'inv':'doc_number','no':'doc_number','no.':'doc_number','id':'doc_number',\n\n  // dates\n  'issue_date':'issue_date','date':'issue_date','invoice_date':'issue_date',\n\n  // party\n  'customer':'customer','customer_name':'customer','party':'customer',\n  'vendor':'vendor','vendor_name':'vendor','supplier':'vendor','supplier_name':'vendor',\n\n  // money + tax\n  'currency':'currency','curr':'currency',\n  'subtotal':'subtotal','tax':'tax','total':'total','shipping':'shipping',\n  'tax_rate':'tax_rate','rate':'tax_rate',\n  'tax_type':'tax_type','sst':'tax_type','vat':'tax_type','gst':'tax_type',\n\n  // terms\n  'payment_term':'payment_term','payment_terms':'payment_term','terms':'payment_term',\n}));\n\nconst normalizeKeyToken = (t) =>\n  String(t || '')\n    .trim()\n    .replace(/^[#_.\\-]+/, '')        // strip leading symbols like _, #, -, .\n    .toLowerCase()\n    .replace(/\\s+/g, '_');\n\nconst toKey = (k) => {\n  const canon = normalizeKeyToken(k);\n  return aliasMap.get(canon) || canon;\n};\n\nconst stripQuotes = (v) => {\n  const s = String(v).trim();\n  const m = s.match(/^['\"](.*)['\"]$/);\n  return m ? m[1] : s;\n};\n\nconst toVal = (k, v) => {\n  v = stripQuotes(v);\n  const numKeys = /^(subtotal|tax|total|shipping|tax_rate)$/i;\n  if (numKeys.test(k)) {\n    const n = Number(String(v).replace(/[, ]/g,''));\n    return Number.isFinite(n) ? n : v;\n  }\n  return String(v).trim();\n};\n\nconst parsePairs = (s) => {\n  const out = {};\n  if (!s) return out;\n\n  // allow both ; and whitespace-separated pairs; key=value or key:value\n  const parts = s.split(/\\s*;\\s*|\\s+(?=\\S+=|\\S+:)/g).filter(Boolean);\n  for (const p of parts) {\n    const m = String(p).match(/^([^=:\\s]+)\\s*[:=]\\s*(.+)$/);\n    if (!m) continue;\n    const k = toKey(m[1]);\n    const v = toVal(k, m[2]);\n    out[k] = v;\n  }\n  return out;\n};\n\n// ---------- parse command ----------\nif (!raw) {\n  return { json: { ok:false, error:'Empty message', wa_text: raw, wa_from: from } };\n}\n\nconst cmdMatch = raw.match(/^([A-Za-z]+)\\b/i);\nif (!cmdMatch) {\n  return { json: { ok:false, error:'Missing command keyword', wa_text: raw, wa_from: from } };\n}\nconst command = cmdMatch[1].toUpperCase();\nlet rest = raw.slice(cmdMatch[0].length).trim();\n\n// Try to read an ID first (token without '='), otherwise treat as “no ID given”\nlet review_id = '';\nif (rest) {\n  const first = (rest.split(/\\s+/,1)[0] || '').trim();\n  if (first && !/[=:\\uFF1D]/.test(first)) {\n    review_id = first;\n    rest = rest.slice(first.length).trim();\n  }\n}\n\n// Build outputs per command\nlet reason = '';\nlet corrections = {};\n\nif (command === 'REJECT') {\n  reason = rest;\n} else if (command === 'CORRECT') {\n  corrections = parsePairs(rest);\n}\n\n// Normalize keys again (suggestion C)\nconst corrNorm = {};\nfor (const [k,v] of Object.entries(corrections)) {\n  const nk = toKey(k);\n  corrNorm[nk] = toVal(nk, v);\n}\n\nreturn {\n  json: {\n    ok: true,\n    command,                // APPROVE | REJECT | CORRECT\n    review_id,              // may be '' if not provided\n    needs_lookup: !review_id,\n    reason,\n    corrections: corrNorm,\n    approver_from: from,\n    wa_text: raw,\n  }\n};\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        720,
        -144
      ],
      "id": "7c123915-be81-4ed5-970c-71038a74a453",
      "name": "Parse Command"
    },
    {
      "parameters": {
        "mode": "runOnceForEachItem",
        "jsCode": "// @ts-nocheck\nconst id = String($json.review_id);\nconst rows = $('Read exceptions_log2').all().map(i=>i.json);\n\n// Find exact match by review_id (column header must be \"review_id\")\nconst row = rows.find(r => String(r.review_id) === id) || null;\n\nreturn { json: { ...$json, exception_row: row } };\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1296,
        -144
      ],
      "id": "5dc6d72e-55e2-4ff3-a3ab-b14c6993b8d0",
      "name": "Pick Row by review_id"
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict",
            "version": 2
          },
          "conditions": [
            {
              "id": "eb5c0951-2d2f-4a65-a1f5-7b3febb098a0",
              "leftValue": "={{$json.exception_row.review_id}}",
              "rightValue": "",
              "operator": {
                "type": "string",
                "operation": "notEmpty",
                "singleValue": true
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "type": "n8n-nodes-base.if",
      "typeVersion": 2.2,
      "position": [
        1584,
        -144
      ],
      "id": "e3663add-6691-4be7-ab7a-5a7dd3d4397c",
      "name": "If1"
    },
    {
      "parameters": {
        "operation": "send",
        "phoneNumberId": "894424953747457",
        "recipientPhoneNumber": "={{ $('Parse Command').item.json.wa_from }}",
        "textBody": "=Review ID {{$json.review_id}} not found or already closed.",
        "additionalFields": {}
      },
      "type": "n8n-nodes-base.whatsApp",
      "typeVersion": 1.1,
      "position": [
        1872,
        336
      ],
      "id": "38383eb2-e5df-495b-993a-c9b4f53ede07",
      "name": "Whatsapp Reply (Not Found)",
      "webhookId": "264cb1c3-408f-4add-a9c1-02fec52964a3",
      "credentials": {
        "whatsAppApi": {
          "id": "JMiSrW34DEwGkuPT",
          "name": "WhatsApp account"
        }
      }
    },
    {
      "parameters": {
        "rules": {
          "values": [
            {
              "conditions": {
                "options": {
                  "caseSensitive": true,
                  "leftValue": "",
                  "typeValidation": "strict",
                  "version": 2
                },
                "conditions": [
                  {
                    "leftValue": "={{ $('Parse Command').item.json.command }}",
                    "rightValue": "APPROVE",
                    "operator": {
                      "type": "string",
                      "operation": "equals"
                    },
                    "id": "2abe263b-f86b-48ca-893e-d043c2b533ae"
                  }
                ],
                "combinator": "and"
              },
              "renameOutput": true,
              "outputKey": "APPROVE"
            },
            {
              "conditions": {
                "options": {
                  "caseSensitive": true,
                  "leftValue": "",
                  "typeValidation": "strict",
                  "version": 2
                },
                "conditions": [
                  {
                    "id": "db1428be-e49f-44e7-9239-1c99987cf805",
                    "leftValue": "={{ $('Parse Command').item.json.command }}",
                    "rightValue": "CORRECT",
                    "operator": {
                      "type": "string",
                      "operation": "equals",
                      "name": "filter.operator.equals"
                    }
                  }
                ],
                "combinator": "and"
              },
              "renameOutput": true,
              "outputKey": "CORRECT"
            },
            {
              "conditions": {
                "options": {
                  "caseSensitive": true,
                  "leftValue": "",
                  "typeValidation": "strict",
                  "version": 2
                },
                "conditions": [
                  {
                    "id": "a3fe390c-6f83-4ce2-8f29-8b2c9506f935",
                    "leftValue": "={{ $('Parse Command').item.json.command }}",
                    "rightValue": "REJECT",
                    "operator": {
                      "type": "string",
                      "operation": "equals",
                      "name": "filter.operator.equals"
                    }
                  }
                ],
                "combinator": "and"
              },
              "renameOutput": true,
              "outputKey": "REJECT"
            }
          ]
        },
        "options": {}
      },
      "type": "n8n-nodes-base.switch",
      "typeVersion": 3.3,
      "position": [
        1872,
        -320
      ],
      "id": "180e18d8-c80b-454f-90de-9aa0635a5c8e",
      "name": "Switch"
    },
    {
      "parameters": {
        "operation": "update",
        "documentId": {
          "__rl": true,
          "value": "1S8guRrH8b-z0I7axmZfagJyx9aykK8hygcI2RDn1X7E",
          "mode": "list",
          "cachedResultName": "Exceptions_Log",
          "cachedResultUrl": "https://docs.google.com/spreadsheets/d/1S8guRrH8b-z0I7axmZfagJyx9aykK8hygcI2RDn1X7E/edit?usp=drivesdk"
        },
        "sheetName": {
          "__rl": true,
          "value": "gid=0",
          "mode": "list",
          "cachedResultName": "Sheet1",
          "cachedResultUrl": "https://docs.google.com/spreadsheets/d/1S8guRrH8b-z0I7axmZfagJyx9aykK8hygcI2RDn1X7E/edit#gid=0"
        },
        "columns": {
          "mappingMode": "defineBelow",
          "value": {
            "status": "approved",
            "reason": "=Approved by {{ $('Parse Command').item.json.wa_from }}",
            "updated_at": "={{$now}}",
            "review_id": "={{$json.review_id}}",
            "doc_type": "={{ $('If1').item.json.doc_type }}",
            "doc_number": "={{ $('If1').item.json.doc_number }}",
            "vendor ": "={{ $('If1').item.json['vendor '] }}",
            "customer": "={{ $('If1').item.json.customer }}",
            "issues": "={{ $('If1').item.json.issues }}",
            "channel": "={{ $('If1').item.json.channel }}",
            "approver_phone ": "={{ $('If1').item.json['approver_phone '] }}",
            "requestor_phone": "={{ $('If1').item.json['approver_phone '] }}",
            "snapshot_json": "={{ $('If1').item.json.snapshot_json }}",
            "corrections_json": "={{ $('If1').item.json.corrections_json }}",
            "created_at": "={{ $('If1').item.json.created_at }}"
          },
          "matchingColumns": [
            "review_id"
          ],
          "schema": [
            {
              "id": "review_id",
              "displayName": "review_id",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true,
              "removed": false
            },
            {
              "id": "status",
              "displayName": "status",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true
            },
            {
              "id": "doc_type",
              "displayName": "doc_type",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true
            },
            {
              "id": "doc_number",
              "displayName": "doc_number",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true
            },
            {
              "id": "vendor ",
              "displayName": "vendor ",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true
            },
            {
              "id": "customer",
              "displayName": "customer",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true
            },
            {
              "id": "issues",
              "displayName": "issues",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true
            },
            {
              "id": "channel",
              "displayName": "channel",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true
            },
            {
              "id": "approver_phone ",
              "displayName": "approver_phone ",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true
            },
            {
              "id": "requestor_phone",
              "displayName": "requestor_phone",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true
            },
            {
              "id": "snapshot_json",
              "displayName": "snapshot_json",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true
            },
            {
              "id": "corrections_json",
              "displayName": "corrections_json",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true
            },
            {
              "id": "reason",
              "displayName": "reason",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true
            },
            {
              "id": "created_at",
              "displayName": "created_at",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true
            },
            {
              "id": "updated_at",
              "displayName": "updated_at",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true,
              "removed": false
            },
            {
              "id": "row_number",
              "displayName": "row_number",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "number",
              "canBeUsedToMatch": true,
              "readOnly": true,
              "removed": true
            }
          ],
          "attemptToConvertTypes": false,
          "convertFieldsToString": false
        },
        "options": {}
      },
      "type": "n8n-nodes-base.googleSheets",
      "typeVersion": 4.7,
      "position": [
        2544,
        -496
      ],
      "id": "e15dbc66-602b-45e2-8f30-c01067cd7f29",
      "name": "Update row in sheet",
      "credentials": {
        "googleSheetsOAuth2Api": {
          "id": "UyGfxGtg3Jm7hDky",
          "name": "Google Sheets account"
        }
      }
    },
    {
      "parameters": {
        "operation": "update",
        "documentId": {
          "__rl": true,
          "value": "1S8guRrH8b-z0I7axmZfagJyx9aykK8hygcI2RDn1X7E",
          "mode": "list",
          "cachedResultName": "Exceptions_Log",
          "cachedResultUrl": "https://docs.google.com/spreadsheets/d/1S8guRrH8b-z0I7axmZfagJyx9aykK8hygcI2RDn1X7E/edit?usp=drivesdk"
        },
        "sheetName": {
          "__rl": true,
          "value": "gid=0",
          "mode": "list",
          "cachedResultName": "Sheet1",
          "cachedResultUrl": "https://docs.google.com/spreadsheets/d/1S8guRrH8b-z0I7axmZfagJyx9aykK8hygcI2RDn1X7E/edit#gid=0"
        },
        "columns": {
          "mappingMode": "defineBelow",
          "value": {
            "review_id": "={{$json.review_id}}",
            "status": "rejected",
            "reason": "={{$json.reason || 'Rejected'}}",
            "updated_at": "={{$now}}"
          },
          "matchingColumns": [
            "review_id"
          ],
          "schema": [
            {
              "id": "review_id",
              "displayName": "review_id",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true,
              "removed": false
            },
            {
              "id": "status",
              "displayName": "status",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true
            },
            {
              "id": "doc_type",
              "displayName": "doc_type",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true
            },
            {
              "id": "doc_number",
              "displayName": "doc_number",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true
            },
            {
              "id": "vendor ",
              "displayName": "vendor ",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true
            },
            {
              "id": "customer",
              "displayName": "customer",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true
            },
            {
              "id": "issues",
              "displayName": "issues",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true
            },
            {
              "id": "channel",
              "displayName": "channel",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true
            },
            {
              "id": "approver_phone ",
              "displayName": "approver_phone ",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true
            },
            {
              "id": "requestor_phone",
              "displayName": "requestor_phone",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true
            },
            {
              "id": "snapshot_json",
              "displayName": "snapshot_json",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true
            },
            {
              "id": "corrections_json",
              "displayName": "corrections_json",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true
            },
            {
              "id": "reason",
              "displayName": "reason",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true
            },
            {
              "id": "created_at",
              "displayName": "created_at",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true
            },
            {
              "id": "updated_at",
              "displayName": "updated_at",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true
            },
            {
              "id": "row_number",
              "displayName": "row_number",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "number",
              "canBeUsedToMatch": true,
              "readOnly": true,
              "removed": true
            }
          ],
          "attemptToConvertTypes": false,
          "convertFieldsToString": false
        },
        "options": {}
      },
      "type": "n8n-nodes-base.googleSheets",
      "typeVersion": 4.7,
      "position": [
        2096,
        224
      ],
      "id": "36e21433-522b-4244-80ec-c71ed3609670",
      "name": "Update row in sheet1",
      "credentials": {
        "googleSheetsOAuth2Api": {
          "id": "UyGfxGtg3Jm7hDky",
          "name": "Google Sheets account"
        }
      }
    },
    {
      "parameters": {
        "operation": "update",
        "documentId": {
          "__rl": true,
          "value": "1S8guRrH8b-z0I7axmZfagJyx9aykK8hygcI2RDn1X7E",
          "mode": "list",
          "cachedResultName": "Exceptions_Log",
          "cachedResultUrl": "https://docs.google.com/spreadsheets/d/1S8guRrH8b-z0I7axmZfagJyx9aykK8hygcI2RDn1X7E/edit?usp=drivesdk"
        },
        "sheetName": {
          "__rl": true,
          "value": "gid=0",
          "mode": "list",
          "cachedResultName": "Sheet1",
          "cachedResultUrl": "https://docs.google.com/spreadsheets/d/1S8guRrH8b-z0I7axmZfagJyx9aykK8hygcI2RDn1X7E/edit#gid=0"
        },
        "columns": {
          "mappingMode": "defineBelow",
          "value": {
            "review_id": "={{$json.review_id}}",
            "status": "corrected",
            "corrections_json": "={{ $('Parse Command').item.json.corrections }}",
            "reason": "Corrections supplied",
            "updated_at": "={{$now}}",
            "snapshot_json": "={{ $json.row.snapshot_json }}",
            "approver_phone ": "={{ $json.row['approver_phone '] }}",
            "customer": "={{ $json.row.customer }}",
            "vendor ": "={{ $json.row['vendor '] }}",
            "doc_number": "={{ $json.row.doc_number }}",
            "doc_type": "={{ $json.row.doc_type }}",
            "channel": "={{ $json.row.channel }}",
            "requestor_phone": "={{ $json.row.requestor_phone }}",
            "issues": "={{ $json.row.issues }}",
            "created_at": "={{ $json.row.created_at }}"
          },
          "matchingColumns": [
            "review_id"
          ],
          "schema": [
            {
              "id": "review_id",
              "displayName": "review_id",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true,
              "removed": false
            },
            {
              "id": "status",
              "displayName": "status",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true
            },
            {
              "id": "doc_type",
              "displayName": "doc_type",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true
            },
            {
              "id": "doc_number",
              "displayName": "doc_number",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true
            },
            {
              "id": "vendor ",
              "displayName": "vendor ",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true
            },
            {
              "id": "customer",
              "displayName": "customer",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true
            },
            {
              "id": "issues",
              "displayName": "issues",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true,
              "removed": false
            },
            {
              "id": "channel",
              "displayName": "channel",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true
            },
            {
              "id": "approver_phone ",
              "displayName": "approver_phone ",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true
            },
            {
              "id": "requestor_phone",
              "displayName": "requestor_phone",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true
            },
            {
              "id": "snapshot_json",
              "displayName": "snapshot_json",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true
            },
            {
              "id": "corrections_json",
              "displayName": "corrections_json",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true
            },
            {
              "id": "reason",
              "displayName": "reason",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true
            },
            {
              "id": "created_at",
              "displayName": "created_at",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true
            },
            {
              "id": "updated_at",
              "displayName": "updated_at",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true
            },
            {
              "id": "row_number",
              "displayName": "row_number",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "number",
              "canBeUsedToMatch": true,
              "readOnly": true,
              "removed": true
            }
          ],
          "attemptToConvertTypes": false,
          "convertFieldsToString": false
        },
        "options": {}
      },
      "type": "n8n-nodes-base.googleSheets",
      "typeVersion": 4.7,
      "position": [
        2544,
        32
      ],
      "id": "6149c93e-c5cc-4db2-83cc-9490b830becb",
      "name": "Update row in sheet2",
      "credentials": {
        "googleSheetsOAuth2Api": {
          "id": "UyGfxGtg3Jm7hDky",
          "name": "Google Sheets account"
        }
      }
    },
    {
      "parameters": {
        "documentId": {
          "__rl": true,
          "value": "1S8guRrH8b-z0I7axmZfagJyx9aykK8hygcI2RDn1X7E",
          "mode": "list",
          "cachedResultName": "Exceptions_Log",
          "cachedResultUrl": "https://docs.google.com/spreadsheets/d/1S8guRrH8b-z0I7axmZfagJyx9aykK8hygcI2RDn1X7E/edit?usp=drivesdk"
        },
        "sheetName": {
          "__rl": true,
          "value": "gid=0",
          "mode": "list",
          "cachedResultName": "Sheet1",
          "cachedResultUrl": "https://docs.google.com/spreadsheets/d/1S8guRrH8b-z0I7axmZfagJyx9aykK8hygcI2RDn1X7E/edit#gid=0"
        },
        "filtersUI": {
          "values": [
            {
              "lookupColumn": "review_id",
              "lookupValue": "={{ $('Pick Row by review_id').item.json.review_id }}"
            }
          ]
        },
        "options": {}
      },
      "type": "n8n-nodes-base.googleSheets",
      "typeVersion": 4.7,
      "position": [
        3360,
        -400
      ],
      "id": "91d72d70-65b6-4a68-afd0-35af967337b3",
      "name": "Read exceptions_log",
      "credentials": {
        "googleSheetsOAuth2Api": {
          "id": "UyGfxGtg3Jm7hDky",
          "name": "Google Sheets account"
        }
      }
    },
    {
      "parameters": {
        "resource": "media",
        "operation": "mediaUrlGet",
        "mediaGetId": "={{ $json.media.id }}"
      },
      "type": "n8n-nodes-base.whatsApp",
      "typeVersion": 1.1,
      "position": [
        48,
        496
      ],
      "id": "4b810b2a-7a3d-4940-b3ad-e838b4d801df",
      "name": "Download media",
      "webhookId": "c8dd8bb7-875c-4070-83a4-a39dd176878f",
      "credentials": {
        "whatsAppApi": {
          "id": "JMiSrW34DEwGkuPT",
          "name": "WhatsApp account"
        }
      }
    },
    {
      "parameters": {
        "url": "={{$json[\"url\"]}}",
        "authentication": "predefinedCredentialType",
        "nodeCredentialType": "whatsAppApi",
        "options": {
          "response": {
            "response": {
              "responseFormat": "file",
              "outputPropertyName": "file"
            }
          }
        }
      },
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.3,
      "position": [
        272,
        496
      ],
      "id": "7f48d1bd-9f40-4482-8c7f-04a328834e34",
      "name": "HTTP Request",
      "credentials": {
        "whatsAppApi": {
          "id": "JMiSrW34DEwGkuPT",
          "name": "WhatsApp account"
        }
      }
    },
    {
      "parameters": {
        "operation": "pdf",
        "binaryPropertyName": "file",
        "options": {}
      },
      "type": "n8n-nodes-base.extractFromFile",
      "typeVersion": 1,
      "position": [
        720,
        528
      ],
      "id": "de12906c-0796-4813-ba10-9e0c0fb82347",
      "name": "Extract from File"
    },
    {
      "parameters": {},
      "type": "n8n-nodes-base.merge",
      "typeVersion": 3.2,
      "position": [
        2096,
        704
      ],
      "id": "ad378be6-2fcd-4204-9718-060a7cd25a41",
      "name": "Merge"
    },
    {
      "parameters": {
        "mode": "runOnceForEachItem",
        "jsCode": "// @ts-nocheck\n// Parse Gemini JSON string, unescape text, and preserve $json.text if LLM didn't send one\n\n// 1) Keep whatever text is already on this item (from PDF extractor or OCR)\nconst originalText = String($json.text ?? \"\");\n\n// 2) Grab the raw model output (common Gemini shapes)\nlet raw =\n  $json.candidates?.[0]?.content?.parts?.[0]?.text ??\n  $json[0]?.content?.parts?.[0]?.text ??\n  $json.output_text ??\n  \"\";\n\n// 3) Strip code fences if any\nraw = String(raw).replace(/```json|```/g, \"\").trim();\n\n// 4) Parse JSON; if it's wrapped in prose, pull the {...}\nlet parsed = null;\ntry {\n  parsed = JSON.parse(raw);\n} catch {\n  const m = raw.match(/\\{[\\s\\S]*\\}/);\n  if (m) { try { parsed = JSON.parse(m[0]); } catch {} }\n}\n\n// 5) Normalize values\nconst docType = parsed?.doc_type ?? \"unknown\";\nconst conf    = Number(parsed?.confidence ?? 0.6);\n\n// Turn escaped \\n and \\t into real newlines/tabs if LLM provided text; otherwise keep original\nconst llmText = typeof parsed?.text === \"string\"\n  ? parsed.text.replace(/\\\\n/g, \"\\n\").replace(/\\\\t/g, \"\\t\")\n  : originalText;\n\n// 6) Emit compact payload for ensemble AND keep text for downstream extraction\nreturn {\n  json: {\n    ...$json,\n    text: llmText,\n    sources: {\n      ...( $json.sources || {} ),\n      llm: { type: docType, confidence: conf, text: llmText }\n    }\n  }\n};\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1872,
        528
      ],
      "id": "8492e66e-a7ef-4c37-8203-ecf722056e39",
      "name": "Parse gemini output"
    },
    {
      "parameters": {
        "mode": "runOnceForEachItem",
        "jsCode": "// @ts-nocheck\nconst h = $json.sources?.heuristic || { type: 'unknown', confidence: 0.6, text: $json.text };\nconst l = $json.sources?.llm       || { type: 'unknown', confidence: 0.6, text: $json.text };\n\n// pick winner by confidence (bias slightly to LLM if tied)\nconst winner = (l.confidence + 0.01 >= h.confidence) ? l : h;\n\n// blended confidence (mild LLM weight)\nconst confidence = +(((h.confidence * 0.4) + (l.confidence * 0.6))).toFixed(2);\n\n// keep a clean top-level doc_type/confidence, preserve text, and keep both sources\nreturn {\n  json: {\n    ...$json,\n    doc_type: winner.type,\n    confidence,\n    text: winner.text || $json.text || \"\",\n    sources: {\n      heuristic: { type: h.type, confidence: h.confidence, text: h.text || $json.text || \"\" },\n      llm:       { type: l.type, confidence: l.confidence, text: l.text || $json.text || \"\" }\n    }\n  }\n};\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        2320,
        704
      ],
      "id": "bbb59548-ed38-43da-be6f-c81295a1cbd2",
      "name": "Heuristic + LLM (Ensemble)"
    },
    {
      "parameters": {
        "mode": "runOnceForEachItem",
        "jsCode": "// @ts-nocheck\n\n// Get text safely\nconst raw = ($json.text ?? \"\");\nconst text = String(raw);\n\n// Weighted heuristics (same logic you already understand)\nconst heuristics = {\n  invoice: [\n    { re: /tax\\s+invoice/i, w: 0.92 },\n    { re: /\\binvoice\\b/i,   w: 0.90 },\n    { re: /inv[-\\s]?\\d+/i,  w: 0.80 }\n  ],\n  quotation: [\n    { re: /\\bquotation\\b/i, w: 0.85 },\n    { re: /\\bquote\\b/i,     w: 0.85 },\n    { re: /pro\\s*forma/i,   w: 0.75 }\n  ],\n  receipt: [\n    { re: /\\breceipt\\b/i,    w: 0.90 },\n    { re: /receipt\\s*no/i,   w: 0.80 }\n  ],\n  credit_note: [\n    { re: /credit\\s+note/i,  w: 0.90 },\n    { re: /credit\\s+memo/i,  w: 0.80 }\n  ],\n  delivery_order: [\n    { re: /delivery\\s+order/i, w: 0.85 },\n    { re: /\\bdo[-\\s]?\\d+/i,    w: 0.85 }\n  ],\n  bill: [\n    { re: /\\bbill\\b/i,       w: 0.75 }\n  ]\n};\n\n// Defaults\nlet heur_doc_type = \"unknown\";\nlet heur_confidence = 0.60;\n\n// Scan cues\nfor (const [type, patterns] of Object.entries(heuristics)) {\n  for (const { re, w } of patterns) {\n    if (re.test(text) && w > heur_confidence) {\n      heur_doc_type = type;\n      heur_confidence = w;\n    }\n  }\n}\n\n// Return **ONE** item only\nreturn {\n  json: {\n    heur_doc_type,\n    heur_confidence: Number(heur_confidence.toFixed(2)),\n    text: raw\n  }\n};\n\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1872,
        896
      ],
      "id": "b82e881f-b21f-4e8b-b26a-59dd86b4c3fe",
      "name": "Heuristics Classification"
    },
    {
      "parameters": {
        "jsCode": "// Run Once for All Items\nconst items = $input.all();\n\nconst updatedItems = items.map((item) => {\n  // keep existing JSON and BINARY so attachments aren’t lost\n  const json = { ...(item.json || {}) };\n  const bin  = item.binary;\n\n  // try to find a sender string from common fields (email or WhatsApp)\n  let sender =\n    json?.from ??\n    json?.headers?.from ??\n    json?.from_email ??\n    json?.messages?.[0]?.from ??\n    json?.contacts?.[0]?.wa_id ??\n    \"\";\n\n  sender = String(sender).trim();\n\n  // if it's \"Name <email@domain>\", extract the email\n  const m = sender.match(/<([^>]+)>/);\n  if (m && m[1]) sender = m[1];\n\n  // your original logic, made safe\n  if (sender && sender.includes(\"@\")) {\n    // email → store local part before @\n    json.sender = sender.split(\"@\")[0];\n    json.channel = \"email\";\n  } else if (sender && sender.includes(\"whatsapp\")) {\n    // strings like \"whatsapp:+6011xxxx\" or \"whatsapp:6011xxxx\"\n    const parts = sender.split(\":\");\n    json.sender = (parts[1] || \"\").replace(/\\D/g, \"\"); // keep digits only\n    json.channel = \"whatsapp\";\n  } else if (/^\\+?\\d{7,15}$/.test(sender)) {\n    // bare phone number → treat as WhatsApp\n    json.sender = sender.replace(/^\\+/, \"\");\n    json.channel = \"whatsapp\";\n  } else {\n    // fallback: keep what we have, try to infer channel from structure\n    json.sender = sender || \"\";\n    json.channel = (json.messages || json.contacts) ? \"whatsapp\" : \"email\";\n  }\n\n  return {\n    json,\n    binary: bin ? { ...bin } : undefined, // preserve any attached file(s)\n  };\n});\n\nreturn updatedItems;\n\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        2544,
        704
      ],
      "id": "8a004d2e-eb3f-40f8-9529-2b61a75f21eb",
      "name": "Normalize sender"
    },
    {
      "parameters": {
        "mode": "runOnceForEachItem",
        "jsCode": "// @ts-nocheck\n// Debug node - Place this IMMEDIATELY after \"Extract from File\" node\n// This will show you what Extract from File is actually outputting\n\nconst item = $json;\nconst binary = $binary;\n\nconsole.log('=== EXTRACT FROM FILE OUTPUT ===');\nconsole.log('JSON keys:', Object.keys(item));\nconsole.log('Has text:', !!item.text);\nconsole.log('Text length:', item.text ? item.text.length : 0);\nconsole.log('Text preview:', item.text ? item.text.slice(0, 100) : 'NO TEXT');\nconsole.log('Binary keys:', binary ? Object.keys(binary) : 'NO BINARY');\n\n// Check if there are any error fields\nconsole.log('Has error:', !!item.error);\nif (item.error) console.log('Error:', item.error);\n\nconst debug = {\n  source_node: 'Extract from File',\n  json_keys: Object.keys(item),\n  has_text: !!item.text,\n  text_length: item.text ? item.text.length : 0,\n  has_binary: !!binary,\n  binary_keys: binary ? Object.keys(binary) : [],\n  has_error: !!item.error,\n  error_message: item.error || null,\n  \n  // Check what fields are present\n  available_data: {\n    text: item.text ? 'EXISTS' : 'MISSING',\n    data: item.data ? 'EXISTS' : 'MISSING',\n    content: item.content ? 'EXISTS' : 'MISSING',\n    extracted_text: item.extracted_text ? 'EXISTS' : 'MISSING',\n  }\n};\n\n// Pass through original data + debug info\nreturn {\n  json: {\n    ...item,\n    _extract_debug: debug\n  },\n  binary: binary\n};"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1008,
        528
      ],
      "id": "b1e598f5-a550-4223-90b0-c210ce9bde39",
      "name": "Debug Extract from File Output"
    },
    {
      "parameters": {
        "mode": "runOnceForEachItem",
        "jsCode": "// @ts-nocheck\n// Parse LLM Extraction Output from Gemini - IMPROVED VERSION\n\n// Preserve original text\nconst originalText = String($json.text ?? \"\");\n\n// ==================== STEP 1: GET RAW OUTPUT ====================\n// Try multiple possible paths for Gemini response\nlet raw = \"\";\n\n// Path 1: Direct from n8n Gemini node (array response)\nif (Array.isArray($json) && $json.length > 0) {\n  raw = $json[0]?.content?.parts?.[0]?.text ?? \"\";\n  console.log(\"✓ Using array format response\");\n}\n\n// Path 2: content.parts format (common in Gemini)\nif (!raw && $json.content?.parts?.[0]?.text) {\n  raw = $json.content.parts[0].text;\n  console.log(\"✓ Using content.parts format\");\n}\n\n// Path 3: candidates format\nif (!raw && $json.candidates?.[0]?.content?.parts?.[0]?.text) {\n  raw = $json.candidates[0].content.parts[0].text;\n  console.log(\"✓ Using candidates format\");\n}\n\n// Path 4: Direct output_text\nif (!raw && $json.output_text) {\n  raw = $json.output_text;\n  console.log(\"✓ Using output_text format\");\n}\n\n// Path 5: Direct message\nif (!raw && $json.message) {\n  raw = $json.message;\n  console.log(\"✓ Using message format\");\n}\n\nraw = String(raw).trim();\n\nconsole.log(\"=== LLM Parser Debug ===\");\nconsole.log(\"Raw length:\", raw.length);\nconsole.log(\"Raw preview:\", raw.substring(0, 150));\n\n// ==================== STEP 2: CLEAN THE OUTPUT ====================\n// Remove markdown code fences\nlet cleaned = raw\n  .replace(/^```json\\s*/i, \"\")  // Remove opening ```json\n  .replace(/^```\\s*/i, \"\")       // Remove opening ```\n  .replace(/\\s*```$/i, \"\")       // Remove closing ```\n  .trim();\n\nconsole.log(\"After cleaning:\", cleaned.substring(0, 150));\n\n// ==================== STEP 3: EXTRACT JSON ====================\nlet jsonText = cleaned;\n\n// If there's still non-JSON text, try to extract just the JSON object\nif (!cleaned.startsWith(\"{\")) {\n  const match = cleaned.match(/(\\{[\\s\\S]*\\})/);\n  if (match) {\n    jsonText = match[1];\n    console.log(\"✓ Extracted JSON from text\");\n  }\n}\n\n// ==================== STEP 4: PARSE JSON ====================\nlet parsed = null;\n\ntry {\n  parsed = JSON.parse(jsonText);\n  console.log(\"✅ JSON parsed successfully!\");\n} catch (e) {\n  console.error(\"❌ JSON parse failed:\", e.message);\n  console.error(\"Attempted to parse:\", jsonText.substring(0, 200));\n  \n  // If parsing failed, return empty extraction with error\n  return {\n    json: {\n      ...$json,\n      text: originalText,\n      llm_extracted: {\n        doc_number: null,\n        issue_date: null,\n        due_date: null,\n        vendor: null,\n        customer: null,\n        currency: 'MYR',\n        subtotal: null,\n        tax: null,\n        tax_rate: null,\n        tax_type: null,\n        shipping: null,\n        total: null,\n        payment_term: null,\n        line_items: [],\n        extraction_confidence: 0.0,\n        error: `Failed to parse LLM output: ${e.message}`,\n        _raw_output: raw.substring(0, 500)  // Include raw for debugging\n      }\n    }\n  };\n}\n\n// ==================== STEP 5: VALIDATE & NORMALIZE ====================\nconsole.log(\"Parsed fields:\", Object.keys(parsed));\n\nconst llmExtracted = {\n  doc_number: parsed.doc_number || null,\n  issue_date: parsed.issue_date || null,\n  due_date: parsed.due_date || null,\n  vendor: parsed.vendor || null,\n  customer: parsed.customer || null,\n  currency: parsed.currency || 'MYR',\n  subtotal: typeof parsed.subtotal === 'number' ? parsed.subtotal : null,\n  tax: typeof parsed.tax === 'number' ? parsed.tax : null,\n  tax_rate: typeof parsed.tax_rate === 'number' ? parsed.tax_rate : null,\n  tax_type: parsed.tax_type || null,\n  shipping: typeof parsed.shipping === 'number' ? parsed.shipping : null,\n  total: typeof parsed.total === 'number' ? parsed.total : null,\n  payment_term: parsed.payment_term || null,\n  line_items: Array.isArray(parsed.line_items) ? parsed.line_items.map(item => ({\n    description: item.description || '',\n    quantity: typeof item.quantity === 'number' ? item.quantity : null,\n    unit_price: typeof item.unit_price === 'number' ? item.unit_price : null,\n    amount: typeof item.amount === 'number' ? item.amount : null,\n    gl_hint: item.gl_hint || 'Expense: General'\n  })) : [],\n  extraction_confidence: typeof parsed.extraction_confidence === 'number' \n    ? Math.min(1.0, Math.max(0.0, parsed.extraction_confidence))\n    : 0.7\n};\n\nconsole.log(\"✅ Normalized extraction complete\");\nconsole.log(\"Fields extracted:\", Object.keys(llmExtracted).filter(k => llmExtracted[k] != null).length);\n\n// ==================== STEP 6: RETURN ====================\nreturn {\n  json: {\n    ...$json,\n    text: originalText,\n    llm_extracted: llmExtracted,\n    _parser_debug: {\n      raw_length: raw.length,\n      cleaned_length: cleaned.length,\n      json_length: jsonText.length,\n      parse_success: true,\n      fields_found: Object.keys(llmExtracted).filter(k => llmExtracted[k] != null).length\n    }\n  }\n};"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        3120,
        896
      ],
      "id": "4ace6e3f-4c6a-460d-b475-19f50c5f1d5a",
      "name": "LLM Extraction Parser"
    },
    {
      "parameters": {
        "modelId": {
          "__rl": true,
          "value": "models/gemini-2.5-flash",
          "mode": "list",
          "cachedResultName": "models/gemini-2.5-flash"
        },
        "messages": {
          "values": [
            {
              "content": "=You are a precise accounting document data extraction AI.\n\nYour task: Extract ALL key financial fields from the document text below.\n\nDocument Type: {{ $json.doc_type }}\n\nCRITICAL INSTRUCTIONS:\n1. Extract data EXACTLY as it appears in the document\n2. For amounts: extract numbers only (no currency symbols, but note the currency)\n3. For dates: use ISO format YYYY-MM-DD\n4. For line items: extract description, quantity, unit price, and amount\n5. Infer GL account hints based on item descriptions\n6. Output ONLY valid JSON (no code blocks, no explanations)\n\nRequired JSON Structure:\n{\n  \"doc_number\": \"string or null\",\n  \"issue_date\": \"YYYY-MM-DD or null\",\n  \"due_date\": \"YYYY-MM-DD or null\",\n  \"vendor\": \"string or null\",\n  \"customer\": \"string or null\",\n  \"currency\": \"MYR|USD|EUR|SGD\",\n  \"subtotal\": number or null,\n  \"tax\": number or null,\n  \"tax_rate\": number (as decimal, e.g., 0.06 for 6%) or null,\n  \"tax_type\": \"SST|GST|VAT|TAX or null\",\n  \"shipping\": number or null,\n  \"total\": number or null,\n  \"payment_term\": \"string or null\",\n  \"line_items\": [\n    {\n      \"description\": \"string\",\n      \"quantity\": number or null,\n      \"unit_price\": number or null,\n      \"amount\": number or null,\n      \"gl_hint\": \"Asset: X | Expense: Y | COGS: Z | Tax: Input/Output\"\n    }\n  ],\n  \"extraction_confidence\": number (0.0 to 1.0)\n}\n\nGL Account Hints Guide:\n- Office equipment, computers, furniture → \"Asset: Office Equipment\"\n- Software, subscriptions, SaaS → \"Expense: Software & Subscriptions\"\n- Consulting, services → \"Expense: Professional Services\"\n- Inventory, stock, goods → \"COGS: Inventory\"\n- Shipping, delivery, freight → \"Expense: Shipping & Delivery\"\n- Utilities, internet, phone → \"Expense: Utilities\"\n- Rent, lease → \"Expense: Rent\"\n- Tax lines (SST/GST/VAT) → \"Tax: Input/Output Tax\"\n- Everything else → \"Expense: General\"\n\nIMPORTANT RULES:\n- For invoices/quotations: customer = Bill To/Sold To\n- For bills/receipts: vendor = Bill From/Received From\n- If tax rate is shown (e.g., \"6%\"), convert to decimal (0.06)\n- If subtotal + tax doesn't match total, include shipping if present\n- Line items: Skip header rows, footers, and summary lines\n- Confidence: 0.9-1.0 if all key fields present; 0.7-0.89 if some missing; <0.7 if many missing\n\nDocument Text:\n{{ $json.text }}"
            }
          ]
        },
        "options": {}
      },
      "type": "@n8n/n8n-nodes-langchain.googleGemini",
      "typeVersion": 1,
      "position": [
        2768,
        896
      ],
      "id": "9c3c149c-0279-46ee-a7ed-4b2557d9392a",
      "name": "LLM Key Extraction",
      "retryOnFail": true,
      "maxTries": 5,
      "credentials": {
        "googlePalmApi": {
          "id": "K7vMI9od1A66EdV5",
          "name": "Google Gemini(PaLM) Api account 2"
        }
      }
    },
    {
      "parameters": {
        "mode": "runOnceForEachItem",
        "jsCode": "// @ts-nocheck\n// Enhanced Key Extraction for Accounting Documents\n// Processes: Invoice, Quotation, Receipt, Credit Note, Delivery Order, Bill\n\n// Handle missing text gracefully\nif (!$json.text || String($json.text).trim().length === 0) {\n  return {\n    json: {\n      ...$json,\n      extracted: {\n        doc_type: $json.doc_type || 'unknown',\n        doc_number: null,\n        issue_date: null,\n        due_date: null,\n        vendor: null,\n        customer: null,\n        currency: 'MYR',\n        subtotal: null,\n        tax: null,\n        tax_rate: null,\n        tax_type: null,\n        shipping: null,\n        total: null,\n        payment_term: null,\n        line_items: [],\n        validations: {\n          has_doc_number: false,\n          has_issue_date: false,\n          has_subtotal: false,\n          has_total: false,\n          has_tax: false,\n          has_line_items: false,\n          computed_total: 0,\n          total_mismatch: false,\n          mismatch_amount: 0\n        },\n        extraction_confidence: 0.0,\n        error: 'No text content available for extraction'\n      },\n      hash_key: `${$json.doc_type || 'unknown'}|||`\n    }\n  };\n}\n\nconst raw = String($json.text || \"\");\nconst text = raw.replace(/\\r/g, '')\n  ;\n\n// ==================== UTILITY FUNCTIONS ====================\n\nconst first = (m) => (m && m[0]) || null;\nconst onlyNum = (s) => {\n  const cleaned = String(s).replace(/[^0-9.]/g, \"\");\n  const num = parseFloat(cleaned);\n  return isNaN(num) ? null : num;\n};\n\nconst moneyFrom = (re) => {\n  const m = text.match(re);\n  return m ? onlyNum(m[1]) : null;\n};\n\nconst findAny = (...regexes) => {\n  for (const re of regexes) {\n    const m = text.match(re);\n    if (m) return (m[1] || m[0]).trim();\n  }\n  return null;\n};\n\nconst normDate = (s) => {\n  if (!s) return null;\n  // Already ISO format\n  if (/^\\d{4}-\\d{2}-\\d{2}$/.test(s)) return s;\n  \n  // DD/MM/YYYY or DD-MM-YYYY or DD.MM.YYYY\n  const m = s.match(/^(\\d{1,2})[\\/\\-.](\\d{1,2})[\\/\\-.](\\d{2,4})$/);\n  if (!m) return null;\n  \n  const dd = m[1].padStart(2, '0');\n  const mm = m[2].padStart(2, '0');\n  const yyyy = m[3].length === 2 ? ('20' + m[3]) : m[3];\n  \n  return `${yyyy}-${mm}-${dd}`;\n};\n\n// ==================== DOCUMENT TYPE ====================\n\nconst docType = $json.doc_type || $json.heur_doc_type || 'unknown';\n\n// ==================== DOCUMENT NUMBER ====================\n\nconst docNumber = findAny(\n  // Invoice patterns\n  /invoice\\s*(?:no|number|#)[:\\s]*([a-z0-9\\-\\/]+)/i,\n  /\\binv[-\\s]?(\\d+[a-z0-9\\-\\/]*)/i,\n  \n  // Receipt patterns\n  /receipt\\s*(?:no|number|#)[:\\s]*([a-z0-9\\-\\/]+)/i,\n  /\\brcp[-\\s]?(\\d+[a-z0-9\\-\\/]*)/i,\n  \n  // Credit Note patterns\n  /credit\\s*note\\s*(?:no|number|#)[:\\s]*([a-z0-9\\-\\/]+)/i,\n  /\\bcn[-\\s]?(\\d+[a-z0-9\\-\\/]*)/i,\n  \n  // Delivery Order patterns\n  /delivery\\s*order\\s*(?:no|number|#)[:\\s]*([a-z0-9\\-\\/]+)/i,\n  /\\bdo[-\\s]?(\\d+[a-z0-9\\-\\/]*)/i,\n  \n  // Quotation patterns\n  /quotation\\s*(?:no|number|#)[:\\s]*([a-z0-9\\-\\/]+)/i,\n  /quote\\s*(?:no|number|#)[:\\s]*([a-z0-9\\-\\/]+)/i,\n  /\\bq[-\\s]?(\\d+[a-z0-9\\-\\/]*)/i,\n  \n  // Generic fallback\n  /\\b(inv|rcp|cn|do|qtn)[-\\s]?\\d+\\b/i\n) || null;\n\n// ==================== DATES ====================\n\n// Issue Date\nconst dateStr = first(text.match(/(\\d{4}-\\d{2}-\\d{2})/)) ||\n                first(text.match(/(\\d{1,2}[\\/\\-\\.]\\d{1,2}[\\/\\-\\.]\\d{2,4})/));\nconst issueDate = normDate(dateStr);\n\n// Due Date (for invoices)\nconst dueDateStr = findAny(\n  /due\\s*(?:date|on)[:\\s]*(\\d{4}-\\d{2}-\\d{2})/i,\n  /due\\s*(?:date|on)[:\\s]*(\\d{1,2}[\\/\\-\\.]\\d{1,2}[\\/\\-\\.]\\d{2,4})/i,\n  /payment\\s*due[:\\s]*(\\d{4}-\\d{2}-\\d{2})/i,\n  /payment\\s*due[:\\s]*(\\d{1,2}[\\/\\-\\.]\\d{1,2}[\\/\\-\\.]\\d{2,4})/i\n);\nconst dueDate = normDate(dueDateStr);\n\n// ==================== PARTIES (VENDOR / CUSTOMER) ====================\n\nconst billTo = findAny(\n  /bill\\s*to[:\\s]*([a-z0-9 .,&\\-\\/\\(\\)]+?)(?:\\n|address|email|phone|tax|total)/i,\n  /sold\\s*to[:\\s]*([a-z0-9 .,&\\-\\/\\(\\)]+?)(?:\\n|address|email|phone|tax|total)/i,\n  /customer[:\\s]*([a-z0-9 .,&\\-\\/\\(\\)]+?)(?:\\n|address|email|phone|tax|total)/i,\n  /delivered\\s*to[:\\s]*([a-z0-9 .,&\\-\\/\\(\\)]+?)(?:\\n|address|item|status)/i,\n  /received\\s*from[:\\s]*([a-z0-9 .,&\\-\\/\\(\\)]+?)(?:\\n|amount|payment|reference)/i\n);\n\nconst supplier = findAny(\n  /supplier[:\\s]*([a-z0-9 .,&\\-\\/\\(\\)]+?)(?:\\n|address|email|phone|tax|total)/i,\n  /from[:\\s]*([a-z0-9 .,&\\-\\/\\(\\)]+?)(?:\\n|address|email|phone|item)/i,\n  /vendor[:\\s]*([a-z0-9 .,&\\-\\/\\(\\)]+?)(?:\\n|address|email|phone|tax|total)/i\n);\n\n// Determine vendor vs customer based on doc type\nlet vendor = null;\nlet customer = null;\n\nswitch (docType) {\n  case 'invoice':\n  case 'credit_note':\n    customer = billTo || null;\n    vendor = null; // We are the vendor\n    break;\n    \n  case 'bill':\n    vendor = billTo || supplier || null;\n    customer = null;\n    break;\n    \n  case 'quotation':\n    customer = billTo || null;\n    vendor = null;\n    break;\n    \n  case 'receipt':\n    customer = billTo || null; // Who paid us\n    vendor = null;\n    break;\n    \n  case 'delivery_order':\n    customer = billTo || null;\n    vendor = null;\n    break;\n    \n  default:\n    customer = billTo || null;\n    vendor = supplier || null;\n}\n\n// Clean up party names\nif (vendor) vendor = vendor.replace(/\\s{2,}/g, ' ').trim();\nif (customer) customer = customer.replace(/\\s{2,}/g, ' ').trim();\n\n// ==================== CURRENCY ====================\n\nlet currency = 'MYR'; // Default for Malaysia\nif (/\\bmyr\\b|\\brm\\b/i.test(raw)) currency = 'MYR';\nelse if (/\\busd\\b|\\bus\\$|\\$(?!\\d)/i.test(raw)) currency = 'USD';\nelse if (/\\beur\\b|€/i.test(raw)) currency = 'EUR';\nelse if (/\\bsgd\\b|s\\$/i.test(raw)) currency = 'SGD';\n\n// ==================== AMOUNTS ====================\n\n// Subtotal\nconst subtotal = moneyFrom(/\\bsubtotal\\b[:\\s]*(?:rm|myr)?\\s*([0-9,.]+)/i) ||\n                 moneyFrom(/\\btotal\\s*\\((?:excl|excluding)\\s*tax\\)[:\\s]*(?:rm|myr)?\\s*([0-9,.]+)/i);\n\n// Grand Total (prefer this over regular total)\nlet total = moneyFrom(/\\bgrand\\s+total\\b[:\\s]*(?:rm|myr)?\\s*([0-9,.]+)/i);\nif (total === null) {\n  total = moneyFrom(/\\btotal\\b[:\\s]*(?:rm|myr)?\\s*([0-9,.]+)/i) ||\n          moneyFrom(/\\bamount\\b[:\\s]*(?:rm|myr)?\\s*([0-9,.]+)/i);\n}\n\n// Shipping/Delivery\nconst shipping = moneyFrom(/(?:shipping|delivery|freight|courier)[:\\s]*(?:rm|myr)?\\s*([0-9,.]+)/i);\n\n// ==================== TAX HANDLING ====================\n\nlet tax = null;\nlet taxRate = null;\nlet taxType = null;\n\n// Identify tax type\nif (/\\bsst\\b/i.test(text)) taxType = 'SST';\nelse if (/\\bgst\\b/i.test(text)) taxType = 'GST';\nelse if (/\\bvat\\b/i.test(text)) taxType = 'VAT';\nelse if (/\\btax\\b/i.test(text)) taxType = 'TAX';\n\n// Extract tax amount\ntax = moneyFrom(/(?:sst|gst|vat|tax)\\s*\\([^)]*\\)[:\\s]*(?:rm|myr)?\\s*([0-9,.]+)/i) ||\n      moneyFrom(/(?:sst|gst|vat|tax)[:\\s]*(?:rm|myr)?\\s*([0-9,.]+)/i);\n\n// Extract tax rate (percentage)\nconst taxPctMatch = text.match(/(?:sst|gst|vat|tax)[^0-9%]{0,40}?(\\d{1,2}(?:\\.\\d+)?)\\s*%/i);\nif (taxPctMatch) {\n  taxRate = parseFloat(taxPctMatch[1]) / 100;\n}\n\n// If we have subtotal and rate but no tax amount, calculate it\nif (subtotal != null && taxRate != null && tax == null) {\n  tax = +(subtotal * taxRate).toFixed(2);\n}\n\n// If we have subtotal and total but no tax, infer it\nif (subtotal != null && total != null && tax == null) {\n  const inferredTax = total - (subtotal + (shipping || 0));\n  if (inferredTax > 0) {\n    tax = +inferredTax.toFixed(2);\n    \n    // Calculate rate from inferred tax\n    if (subtotal > 0 && taxRate == null) {\n      taxRate = +(tax / subtotal).toFixed(4);\n    }\n  }\n}\n\n// Round tax rate for display\nif (taxRate != null) taxRate = +taxRate.toFixed(4);\n\n// ==================== PAYMENT TERM ====================\n\nconst paymentTerm = findAny(\n  /payment\\s*term[:\\s]*([a-z0-9 \\-]+?)(?:\\n|$|due)/i,\n  /terms?[:\\s]*(\\d+\\s*days?)/i,\n  /net\\s*(\\d+)/i\n) || null;\n\n// ==================== LINE ITEMS EXTRACTION ====================\n\nconst lineItems = [];\nconst lines = raw.split(/\\n+/);\n\nfor (const ln of lines) {\n  const l = ln.trim();\n  if (!l || l.length < 5) continue;\n  \n  // Skip header/footer lines AND document metadata lines\n  if (/^(item|description|qty|quantity|unit price|amount|total|subtotal|tax|grand total|payment|signature|approved|page \\d)/i.test(l)) {\n    continue;\n  }\n  \n  // CRITICAL: Skip lines that are document identifiers (invoice no, date, bill to, etc.)\n  if (/^(invoice|receipt|credit note|delivery order|quotation|bill|date|bill to|customer|vendor|payment term|reference)/i.test(l)) {\n    continue;\n  }\n  \n  // Skip lines with colons that are clearly labels (e.g., \"Invoice No: INV-001\")\n  if (/^[a-z\\s]+\\s*:\\s*[a-z0-9\\-\\/]+$/i.test(l) && !/item:/i.test(l)) {\n    continue;\n  }\n  \n  let desc = null;\n  let qty = null;\n  let unitPrice = null;\n  let amount = null;\n  \n  // Pattern 1: \"Description - Qty units @ Price = Amount\" OR \"Description - Qty units\"\n  // e.g., \"Office Equipment - 5 units @ RM 600 = RM 3,000\" or \"Office Equipment - 5 units\"\n  const p1 = l.match(/(.+?)\\s*[-–]\\s*(\\d+(?:\\.\\d+)?)\\s*(?:units?|pcs?|boxes?)/i);\n  \n  if (p1) {\n    desc = p1[1].trim();\n    qty = parseFloat(p1[2]);\n    \n    // Look for price and amount in the same line\n    const priceAmount = l.match(/(?:@|x)\\s*(?:rm|myr)?\\s*([0-9,.]+)(?:\\s*=?\\s*(?:rm|myr)?\\s*([0-9,.]+))?/i);\n    if (priceAmount) {\n      unitPrice = onlyNum(priceAmount[1]);\n      if (priceAmount[2]) {\n        amount = onlyNum(priceAmount[2]);\n      } else if (qty && unitPrice) {\n        amount = +(qty * unitPrice).toFixed(2);\n      }\n    }\n  } else {\n    // Pattern 2: \"Description: Amount\" (simple format)\n    // But be more strict - must have clear amount pattern\n    const p2 = l.match(/^(.+?)\\s*[:\\-]\\s*(?:rm|myr)\\s*([0-9,.]+)$/i);\n    \n    if (p2 && !/subtotal|total|tax|sst|gst|vat|shipping|delivery|payment|invoice|receipt|date|bill|customer|vendor/i.test(l)) {\n      desc = p2[1].trim();\n      amount = onlyNum(p2[2]);\n      \n      // Try to extract quantity from description\n      const qtyMatch = desc.match(/(\\d+(?:\\.\\d+)?)\\s*(?:units?|pcs?|boxes?)/i);\n      if (qtyMatch) {\n        qty = parseFloat(qtyMatch[1]);\n        // Remove quantity from description for cleaner output\n        desc = desc.replace(/\\s*-?\\s*\\d+(?:\\.\\d+)?\\s*(?:units?|pcs?|boxes?)/i, '').trim();\n      }\n    } else {\n      continue; // Skip this line\n    }\n  }\n  \n  if (!desc || (!amount && !qty)) continue;\n  \n  // Calculate unit price if we have qty and amount\n  if (qty && amount && !unitPrice) {\n    unitPrice = +(amount / qty).toFixed(2);\n  }\n  \n  // Calculate amount if we have qty and unit price but no amount\n  if (qty && unitPrice && !amount) {\n    amount = +(qty * unitPrice).toFixed(2);\n  }\n  \n  // ==================== GL ACCOUNT HINTING ====================\n  \n  const d = desc;\n  let glHint = 'Expense: General';\n  \n  // Asset categories\n  if (/(equipment|hardware|laptop|pc|computer|printer|furniture|vehicle|machinery)/i.test(d)) {\n    glHint = 'Asset: Office Equipment';\n  }\n  // Services\n  else if (/(software|subscription|license|saas|cloud|hosting)/i.test(d)) {\n    glHint = 'Expense: Software & Subscriptions';\n  }\n  else if (/(service|maintenance|repair|consult|professional)/i.test(d)) {\n    glHint = 'Expense: Professional Services';\n  }\n  // Shipping\n  else if (/(delivery|courier|freight|shipping|transport)/i.test(d)) {\n    glHint = 'Expense: Shipping & Delivery';\n  }\n  // Inventory/COGS\n  else if (/(inventory|stock|item|sku|goods|product|supplies|medical|coffee|retail)/i.test(d)) {\n    glHint = 'COGS: Inventory';\n  }\n  // Utilities\n  else if (/(electric|water|gas|utilities|internet|phone|telecom)/i.test(d)) {\n    glHint = 'Expense: Utilities';\n  }\n  // Tax lines\n  else if (/(tax|sst|gst|vat)/i.test(d)) {\n    glHint = 'Tax: Input/Output Tax';\n  }\n  // Rent\n  else if (/(rent|lease|rental)/i.test(d)) {\n    glHint = 'Expense: Rent';\n  }\n  \n  lineItems.push({\n    description: desc,\n    quantity: qty,\n    unit_price: unitPrice,\n    amount: amount,\n    gl_hint: glHint\n  });\n}\n\n// ==================== VALIDATION ====================\n\nconst computedTotal = (subtotal || 0) + (tax || 0) + (shipping || 0);\nconst totalMismatch = (subtotal != null && total != null) \n  ? Math.abs(computedTotal - total) > 0.50  // Allow 50 cents variance\n  : false;\n\n// Extraction confidence scoring\nlet score = 0;\nconst checks = [\n  { condition: docNumber != null, weight: 1.5 },\n  { condition: issueDate != null, weight: 1.5 },\n  { condition: subtotal != null || total != null, weight: 2 },\n  { condition: tax != null || taxRate != null, weight: 1 },\n  { condition: vendor != null || customer != null, weight: 1.5 },\n  { condition: lineItems.length > 0, weight: 1.5 },\n  { condition: !totalMismatch, weight: 1 }\n];\n\nconst maxScore = checks.reduce((sum, c) => sum + c.weight, 0);\nscore = checks.reduce((sum, c) => sum + (c.condition ? c.weight : 0), 0);\n\nconst extractionConfidence = Math.max(0.60, Math.min(1.0, score / maxScore));\n\n// ==================== OUTPUT STRUCTURE ====================\n\nconst extracted = {\n  // Document identifiers\n  doc_type: docType,\n  doc_number: docNumber,\n  issue_date: issueDate,\n  due_date: dueDate,\n  \n  // Parties\n  vendor: vendor,\n  customer: customer,\n  \n  // Financial summary\n  currency: currency,\n  subtotal: subtotal,\n  tax: tax,\n  tax_rate: taxRate,\n  tax_type: taxType,\n  shipping: shipping,\n  total: total,\n  \n  // Terms\n  payment_term: paymentTerm,\n  \n  // Line items\n  line_items: lineItems,\n  \n  // Validation results\n  validations: {\n    has_doc_number: docNumber != null,\n    has_issue_date: issueDate != null,\n    has_subtotal: subtotal != null,\n    has_total: total != null,\n    has_tax: tax != null || taxRate != null,\n    has_line_items: lineItems.length > 0,\n    computed_total: +computedTotal.toFixed(2),\n    total_mismatch: totalMismatch,\n    mismatch_amount: totalMismatch ? +(total - computedTotal).toFixed(2) : 0\n  },\n  \n  // Confidence\n  extraction_confidence: +extractionConfidence.toFixed(2)\n};\n\n// ==================== HASH KEY (for deduplication) ====================\n\nconst hashKey = [\n  extracted.doc_type || '',\n  extracted.doc_number || '',\n  extracted.issue_date || '',\n  extracted.total != null ? extracted.total.toFixed(2) : ''\n].join('|');\n\n// ==================== RETURN ====================\n\nreturn {\n  json: {\n    ...$json,  // Preserve existing fields\n    extracted: extracted,\n    hash_key: hashKey,\n    // Debug info (remove in production)\n    _debug: {\n      text_length: raw.length,\n      lines_processed: lines.length,\n      line_items_found: lineItems.length,\n      amounts_found: {\n        subtotal: subtotal != null,\n        tax: tax != null,\n        total: total != null\n      }\n    }\n  }\n};"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        3120,
        320
      ],
      "id": "8f4a6dac-d73e-475a-a865-8d06c43a35be",
      "name": "Heuristics Key Extraction"
    },
    {
      "parameters": {},
      "type": "n8n-nodes-base.merge",
      "typeVersion": 3.2,
      "position": [
        3344,
        704
      ],
      "id": "b9b580fc-97f5-42b7-870d-f2ab91b8dab1",
      "name": "Merge Extraction"
    },
    {
      "parameters": {
        "jsCode": "// @ts-nocheck\n// Ensemble: Merge Rule-based + LLM Extraction\n// Strategy: Use the best source for each field based on confidence and completeness\n\nconsole.log(\"=== ENSEMBLE EXTRACTION START ===\");\n\n// Get both extractions\nconst rules = $json.extracted || {};\nconst llm = $json.llm_extracted || {};\n\nconsole.log(\"Rules extraction keys:\", Object.keys(rules));\nconsole.log(\"LLM extraction keys:\", Object.keys(llm));\nconsole.log(\"Rules has data:\", Object.keys(rules).length > 0);\nconsole.log(\"LLM has data:\", Object.keys(llm).length > 0);\n\n// Helper: Pick the best value between two sources\nconst pickBest = (ruleVal, llmVal, rulePriority = false) => {\n  // If one is null, use the other\n  if (ruleVal == null && llmVal != null) return llmVal;\n  if (llmVal == null && ruleVal != null) return ruleVal;\n  if (ruleVal == null && llmVal == null) return null;\n  \n  // If rule-based extraction has priority (e.g., for amounts), use it\n  if (rulePriority) return ruleVal;\n  \n  // For strings, prefer the longer/more complete one\n  if (typeof ruleVal === 'string' && typeof llmVal === 'string') {\n    return ruleVal.length >= llmVal.length ? ruleVal : llmVal;\n  }\n  \n  // For numbers, prefer rules (more reliable for financial data)\n  if (typeof ruleVal === 'number') return ruleVal;\n  if (typeof llmVal === 'number') return llmVal;\n  \n  // Default: prefer rule-based\n  return ruleVal;\n};\n\n// Helper: Merge line items intelligently\nconst mergeLineItems = (rulesItems, llmItems) => {\n  // If rules found items, prefer those (more reliable)\n  if (rulesItems && rulesItems.length > 0) {\n    console.log(\"✓ Using rules line items, enhancing with LLM GL hints\");\n    // But enrich with LLM's GL hints if they're better\n    return rulesItems.map((rItem, idx) => {\n      const lItem = llmItems?.[idx];\n      return {\n        ...rItem,\n        gl_hint: (lItem?.gl_hint && lItem.gl_hint !== 'Expense: General') \n          ? lItem.gl_hint \n          : rItem.gl_hint\n      };\n    });\n  }\n  \n  // Otherwise use LLM items\n  console.log(\"✓ Using LLM line items (rules had none)\");\n  return llmItems || [];\n};\n\n// Build the ensemble extraction\nconst ensemble = {\n  // Document identifiers - prefer rules\n  doc_type: rules.doc_type || llm.doc_type || 'unknown',\n  doc_number: pickBest(rules.doc_number, llm.doc_number, true),\n  issue_date: pickBest(rules.issue_date, llm.issue_date, true),\n  due_date: pickBest(rules.due_date, llm.due_date),\n  \n  // Parties - prefer LLM (better at extracting full names)\n  vendor: pickBest(rules.vendor, llm.vendor, false),\n  customer: pickBest(rules.customer, llm.customer, false),\n  \n  // Financial data - ALWAYS prefer rules (more accurate for regex-based amount extraction)\n  currency: rules.currency || llm.currency || 'MYR',\n  subtotal: pickBest(rules.subtotal, llm.subtotal, true),\n  tax: pickBest(rules.tax, llm.tax, true),\n  tax_rate: pickBest(rules.tax_rate, llm.tax_rate, true),\n  tax_type: pickBest(rules.tax_type, llm.tax_type, false),\n  shipping: pickBest(rules.shipping, llm.shipping, true),\n  total: pickBest(rules.total, llm.total, true),\n  \n  // Terms - prefer LLM (better at understanding context)\n  payment_term: pickBest(rules.payment_term, llm.payment_term, false),\n  \n  // Line items - prefer rules but enhance with LLM\n  line_items: mergeLineItems(rules.line_items, llm.line_items),\n  \n  // Validations - recalculate based on ensemble data\n  validations: {\n    has_doc_number: (rules.doc_number || llm.doc_number) != null,\n    has_issue_date: (rules.issue_date || llm.issue_date) != null,\n    has_subtotal: (rules.subtotal || llm.subtotal) != null,\n    has_total: (rules.total || llm.total) != null,\n    has_tax: (rules.tax || llm.tax || rules.tax_rate || llm.tax_rate) != null,\n    has_line_items: (rules.line_items?.length > 0 || llm.line_items?.length > 0),\n    computed_total: rules.validations?.computed_total || 0,\n    total_mismatch: rules.validations?.total_mismatch || false,\n    mismatch_amount: rules.validations?.mismatch_amount || 0\n  },\n  \n  // Confidence - blend both confidences with bias toward rules\n  extraction_confidence: +(\n    (rules.extraction_confidence || 0.6) * 0.6 + \n    (llm.extraction_confidence || 0.6) * 0.4\n  ).toFixed(2),\n  \n  // Metadata\n  extraction_methods: {\n    rules_confidence: rules.extraction_confidence || 0.0,\n    llm_confidence: llm.extraction_confidence || 0.0,\n    fields_from_rules: Object.keys(rules).filter(k => rules[k] != null).length,\n    fields_from_llm: Object.keys(llm).filter(k => llm[k] != null).length\n  }\n};\n\n// Generate hash key for deduplication\nconst hashKey = [\n  ensemble.doc_type || '',\n  ensemble.doc_number || '',\n  ensemble.issue_date || '',\n  ensemble.total != null ? ensemble.total.toFixed(2) : ''\n].join('|');\n\nconsole.log(\"=== ENSEMBLE RESULTS ===\");\nconsole.log(\"Doc type:\", ensemble.doc_type);\nconsole.log(\"Doc number:\", ensemble.doc_number);\nconsole.log(\"Customer:\", ensemble.customer);\nconsole.log(\"Total:\", ensemble.total);\nconsole.log(\"Line items:\", ensemble.line_items.length);\nconsole.log(\"Confidence:\", ensemble.extraction_confidence);\nconsole.log(\"Hash key:\", hashKey);\nconsole.log(\"✅ Ensemble complete!\");\n\n// Return the final merged result\nreturn {\n  json: {\n    // Keep minimal original data\n    doc_type: ensemble.doc_type,\n    confidence: ensemble.extraction_confidence,\n    text: $json.text || '',\n    \n    // Store both source extractions for debugging\n    sources: {\n      rules: rules,\n      llm: llm\n    },\n    \n    // Final ensemble extraction\n    extracted: ensemble,\n    hash_key: hashKey,\n    \n    // Debug info\n    _ensemble_debug: {\n      rule_fields_used: Object.entries(rules).filter(([k, v]) => v != null).length,\n      llm_fields_used: Object.entries(llm).filter(([k, v]) => v != null).length,\n      line_items_source: rules.line_items?.length > 0 ? 'rules' : 'llm',\n      confidence_breakdown: {\n        rules: rules.extraction_confidence,\n        llm: llm.extraction_confidence,\n        ensemble: ensemble.extraction_confidence\n      }\n    }\n  }\n};"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        3568,
        704
      ],
      "id": "4f909ed3-847f-4939-91f8-c245c2d5de2e",
      "name": "Ensemble Extraction"
    },
    {
      "parameters": {
        "mode": "runOnceForEachItem",
        "jsCode": "// @ts-nocheck\n// Module 4: Comprehensive Validation & Enrichment\n// NOW USES GOOGLE SHEETS DATA!\n\nconsole.log(\"=== COMPREHENSIVE VALIDATION & ENRICHMENT (GOOGLE SHEETS) ===\");\n\nconst extracted = $json.extracted || {};\nconst docType = extracted.doc_type || 'unknown';\nconst hashKey = $json.hash_key || '';\n\n// ==================== LOAD MASTER DATA FROM GOOGLE SHEETS ====================\nlet masterData;\ntry {\n  masterData = $('Build Master Data from Google Sheets').first().json;\n  console.log(\"✅ Master data loaded from Google Sheets:\");\n  console.log(\"   - Customers:\", masterData.stats.total_customers);\n  console.log(\"   - Vendors:\", masterData.stats.total_vendors);\n  console.log(\"   - FX Rates:\", masterData.stats.total_currencies);\n  console.log(\"   - Invoice History:\", masterData.stats.total_invoices);\n} catch (error) {\n  console.error(\"❌ ERROR: Could not load master data from Google Sheets!\");\n  console.error(\"   Make sure 'Build Master Data from Google Sheets' node exists and has executed\");\n  throw new Error(\"Master data not available. Check workflow configuration.\");\n}\n\n// Extract master data structures from Google Sheets\nconst VENDOR_CUSTOMER_MASTER = masterData.combined_master || {};\nconst FX_RATES = masterData.fx_rates || { MYR: 1.0 };\nconst INVOICE_HISTORY = masterData.invoice_history || [];\nconst CHART_OF_ACCOUNTS = masterData.chart_of_accounts || {};\nconst BANK_STATEMENT = masterData.bank_statement || [];\n\nconsole.log(\"\\n📊 Using Google Sheets data:\");\nconsole.log(\"   Vendor/Customer Master:\", Object.keys(VENDOR_CUSTOMER_MASTER).length, \"entities\");\nconsole.log(\"   FX Rates:\", Object.keys(FX_RATES).length, \"currencies:\", Object.keys(FX_RATES).join(', '));\nconsole.log(\"   Invoice History:\", INVOICE_HISTORY.length, \"invoices\");\nconsole.log(\"   Chart of Accounts:\", Object.keys(CHART_OF_ACCOUNTS).length, \"accounts\");\n\n// TAX RULES (Keep as business rules)\nconst TAX_RULES = {\n  SST: { standard_rate: 0.06, country: 'MY' },\n  GST: { standard_rate: 0.06, country: 'MY' },\n  TAX: { standard_rate: 0.06, country: 'MY' },\n  VAT: { standard_rate: 0.20, country: 'UK' }\n};\n\n// Initialize results\nconst validationResults = {\n  is_valid: true,\n  errors: [],\n  warnings: [],\n  flags: [],\n  enrichments_applied: [],\n  data_source: 'google_sheets'\n};\n\nconst enrichedData = { ...extracted };\n\n// ==================== 1. VENDOR/CUSTOMER REGISTRY LOOKUP ====================\n\nconsole.log(\"\\n📋 Step 1: Cross-checking vendor/customer registry...\");\n\nlet partyInfo = null;\nconst partyName = extracted.vendor || extracted.customer;\n\nif (partyName) {\n  // Try exact match first\n  partyInfo = VENDOR_CUSTOMER_MASTER[partyName];\n  \n  // Try fuzzy match if exact fails\n  if (!partyInfo) {\n    const normalized = partyName.toLowerCase().trim();\n    for (const [key, value] of Object.entries(VENDOR_CUSTOMER_MASTER)) {\n      if (key.toLowerCase().includes(normalized) || normalized.includes(key.toLowerCase())) {\n        partyInfo = value;\n        validationResults.warnings.push(`Fuzzy matched party: \"${partyName}\" → \"${key}\"`);\n        break;\n      }\n    }\n  }\n  \n  if (partyInfo) {\n    console.log(\"✓ Found in Google Sheets:\", partyInfo.id, `(${partyInfo.type})`);\n    console.log(\"  Name:\", partyInfo.name);\n    console.log(\"  Invoices:\", partyInfo.invoices ? partyInfo.invoices.length : 0);\n    \n    enrichedData.party_id = partyInfo.id;\n    enrichedData.party_type = partyInfo.type;\n    enrichedData.party_name = partyInfo.name;\n    enrichedData.party_tax_id = partyInfo.tax_id;\n    enrichedData.party_currency = partyInfo.currency;\n    enrichedData.party_payment_terms = partyInfo.payment_terms;\n    enrichedData.party_credit_limit = partyInfo.credit_limit;\n    \n    // Add transaction history from Google Sheets\n    enrichedData.party_history = {\n      total_invoices: partyInfo.invoices ? partyInfo.invoices.length : 0,\n      total_revenue: partyInfo.total_revenue || 0,\n      total_purchases: partyInfo.total_purchases || 0,\n      paid_count: partyInfo.paid_invoices || 0,\n      pending_count: partyInfo.pending_invoices || 0\n    };\n    \n    validationResults.enrichments_applied.push('PARTY_INFO_ENRICHED_FROM_GOOGLE_SHEETS');\n    \n    // Validate party type matches document type\n    if (docType === 'invoice' && partyInfo.type !== 'customer') {\n      validationResults.warnings.push(`Document is ${docType} but party is ${partyInfo.type}`);\n    }\n    if (docType === 'bill' && partyInfo.type !== 'vendor') {\n      validationResults.warnings.push(`Document is ${docType} but party is ${partyInfo.type}`);\n    }\n  } else {\n    validationResults.warnings.push(`Party \"${partyName}\" not found in Google Sheets master registry`);\n    validationResults.warnings.push(`Available parties: ${Object.keys(VENDOR_CUSTOMER_MASTER).slice(0, 5).join(', ')}...`);\n    validationResults.flags.push('UNKNOWN_PARTY');\n    enrichedData.party_id = null;\n  }\n} else {\n  validationResults.warnings.push('No vendor/customer name found');\n}\n\n// ==================== 2. RECALCULATE TOTALS ====================\n\nconsole.log(\"\\n🧮 Step 2: Recalculating totals...\");\n\nlet recalculatedSubtotal = extracted.subtotal;\nlet recalculatedTax = extracted.tax;\nlet recalculatedTotal = extracted.total;\n\n// Recalc subtotal from line items\nif (extracted.line_items && extracted.line_items.length > 0) {\n  recalculatedSubtotal = extracted.line_items.reduce((sum, item) => sum + (item.amount || 0), 0);\n  recalculatedSubtotal = +recalculatedSubtotal.toFixed(2);\n  \n  if (extracted.subtotal && Math.abs(recalculatedSubtotal - extracted.subtotal) > 0.50) {\n    validationResults.warnings.push(\n      `Subtotal mismatch: Line items sum to ${recalculatedSubtotal} but document shows ${extracted.subtotal}`\n    );\n    enrichedData.subtotal_recalculated = recalculatedSubtotal;\n    enrichedData.subtotal_original = extracted.subtotal;\n    enrichedData.subtotal_difference = +(recalculatedSubtotal - extracted.subtotal).toFixed(2);\n    validationResults.enrichments_applied.push('SUBTOTAL_RECALCULATED');\n  }\n}\n\n// Recalc total\nif (recalculatedSubtotal != null && recalculatedTax != null) {\n  recalculatedTotal = recalculatedSubtotal + recalculatedTax + (extracted.shipping || 0);\n  recalculatedTotal = +recalculatedTotal.toFixed(2);\n  \n  if (extracted.total && Math.abs(recalculatedTotal - extracted.total) > 0.50) {\n    validationResults.warnings.push(\n      `Total mismatch: Calculated ${recalculatedTotal} but document shows ${extracted.total}`\n    );\n    enrichedData.total_recalculated = recalculatedTotal;\n    enrichedData.total_original = extracted.total;\n    enrichedData.total_difference = +(recalculatedTotal - extracted.total).toFixed(2);\n    validationResults.enrichments_applied.push('TOTAL_RECALCULATED');\n  }\n}\n\n// Store normalized (best) values\nenrichedData.subtotal_normalized = recalculatedSubtotal || extracted.subtotal;\nenrichedData.total_normalized = Math.abs(enrichedData.total_difference || 0) > 0.50 \n  ? recalculatedTotal \n  : extracted.total;\n\n// ==================== 3. INFER MISSING TAX ====================\n\nconsole.log(\"\\n💰 Step 3: Inferring missing tax...\");\n\nif (!extracted.tax && extracted.subtotal && extracted.total) {\n  // Infer tax from total - subtotal\n  const inferredTax = extracted.total - extracted.subtotal - (extracted.shipping || 0);\n  \n  if (inferredTax > 0) {\n    enrichedData.tax_inferred = +inferredTax.toFixed(2);\n    enrichedData.tax_rate_inferred = +(inferredTax / extracted.subtotal).toFixed(4);\n    \n    validationResults.warnings.push(\n      `Tax inferred from total: ${enrichedData.tax_inferred} (${(enrichedData.tax_rate_inferred * 100).toFixed(2)}%)`\n    );\n    validationResults.enrichments_applied.push('TAX_INFERRED');\n    \n    // Try to match to a known tax rate\n    const taxType = extracted.tax_type || 'TAX';\n    const expectedRate = TAX_RULES[taxType]?.standard_rate || 0.06;\n    \n    if (Math.abs(enrichedData.tax_rate_inferred - expectedRate) < 0.01) {\n      enrichedData.tax_type_matched = taxType;\n      validationResults.enrichments_applied.push('TAX_TYPE_MATCHED');\n    }\n  }\n}\n\n// Validate tax rate if present\nif (extracted.tax_rate && extracted.tax_type) {\n  const expectedRate = TAX_RULES[extracted.tax_type]?.standard_rate;\n  \n  if (expectedRate && Math.abs(extracted.tax_rate - expectedRate) > 0.01) {\n    validationResults.warnings.push(\n      `Tax rate ${(extracted.tax_rate * 100).toFixed(2)}% doesn't match expected ${extracted.tax_type} rate ${(expectedRate * 100).toFixed(2)}%`\n    );\n  }\n}\n\n// Store normalized tax\nenrichedData.tax_normalized = extracted.tax || enrichedData.tax_inferred || 0;\nenrichedData.tax_rate_normalized = extracted.tax_rate || enrichedData.tax_rate_inferred || 0;\n\n// ==================== 4. DETECT DUPLICATES (REAL CHECK!) ====================\n\nconsole.log(\"\\n🔍 Step 4: Detecting duplicates in Google Sheets invoice history...\");\n\n// REAL DUPLICATE CHECK using Google Sheets data!\nconst duplicateCheck = INVOICE_HISTORY.find(inv => \n  inv.invoice_number === extracted.doc_number\n);\n\nif (duplicateCheck) {\n  // Found a duplicate!\n  console.log(\"❌ DUPLICATE FOUND!\");\n  console.log(\"   Invoice Number:\", duplicateCheck.invoice_number);\n  console.log(\"   Party:\", duplicateCheck.party_name);\n  console.log(\"   Status:\", duplicateCheck.status);\n  console.log(\"   Total:\", duplicateCheck.total);\n  \n  validationResults.errors.push(\n    `Duplicate detected: ${extracted.doc_number} already exists (Status: ${duplicateCheck.status}, Party: ${duplicateCheck.party_name})`\n  );\n  validationResults.flags.push('DUPLICATE_DETECTED');\n  validationResults.is_valid = false;\n  \n  enrichedData.duplicate_found = true;\n  enrichedData.duplicate_info = {\n    original_invoice: duplicateCheck.invoice_number,\n    original_party: duplicateCheck.party_name,\n    original_total: duplicateCheck.total,\n    original_status: duplicateCheck.status,\n    source: duplicateCheck.source,\n    so_number: duplicateCheck.so_number\n  };\n  \n  validationResults.enrichments_applied.push('DUPLICATE_CHECK_EXECUTED');\n} else {\n  enrichedData.duplicate_found = false;\n  console.log(\"✓ No duplicate found - document is unique\");\n  validationResults.enrichments_applied.push('DUPLICATE_CHECK_PASSED');\n}\n\n// Still prepare hash for audit trail\nif (hashKey && hashKey.split('|').filter(p => p).length >= 3) {\n  enrichedData.duplicate_check_hash = hashKey;\n  enrichedData.duplicate_check_ready = true;\n  const hashParts = hashKey.split('|');\n  enrichedData.duplicate_check_key = {\n    doc_type: hashParts[0],\n    doc_number: hashParts[1],\n    issue_date: hashParts[2],\n    total: hashParts[3]\n  };\n}\n\n// ==================== 5. FX CONVERSION (Using Google Sheets rates!) ====================\n\nconsole.log(\"\\n💱 Step 5: Computing FX conversion using Google Sheets rates...\");\n\nconst docCurrency = extracted.currency || 'MYR';\nconst baseCurrency = 'MYR';\n\nconsole.log(`   Document currency: ${docCurrency}`);\nconsole.log(`   Available FX rates:`, Object.keys(FX_RATES).join(', '));\n\nif (docCurrency !== baseCurrency) {\n  const fxRate = FX_RATES[docCurrency];\n  \n  if (fxRate) {\n    enrichedData.fx_rate = fxRate;\n    enrichedData.fx_rate_source = 'google_sheets';\n    enrichedData.base_currency = baseCurrency;\n    enrichedData.original_currency = docCurrency;\n    \n    enrichedData.subtotal_base = extracted.subtotal ? +(extracted.subtotal * fxRate).toFixed(2) : null;\n    enrichedData.tax_base = extracted.tax ? +(extracted.tax * fxRate).toFixed(2) : null;\n    enrichedData.total_base = extracted.total ? +(extracted.total * fxRate).toFixed(2) : null;\n    \n    console.log(`✓ Converted ${docCurrency} to ${baseCurrency} at rate ${fxRate} (from Google Sheets)`);\n    console.log(`  ${extracted.total} ${docCurrency} = ${enrichedData.total_base} ${baseCurrency}`);\n    \n    validationResults.enrichments_applied.push('FX_CONVERTED_FROM_GOOGLE_SHEETS');\n    validationResults.flags.push('FOREIGN_CURRENCY');\n  } else {\n    validationResults.warnings.push(`FX rate not available in Google Sheets for ${docCurrency}`);\n    validationResults.flags.push('FX_RATE_MISSING');\n    \n    enrichedData.subtotal_base = extracted.subtotal;\n    enrichedData.tax_base = extracted.tax;\n    enrichedData.total_base = extracted.total;\n    enrichedData.base_currency = docCurrency;\n    enrichedData.fx_rate_source = 'not_converted';\n  }\n} else {\n  enrichedData.fx_rate = 1.0;\n  enrichedData.fx_rate_source = 'base_currency';\n  enrichedData.base_currency = baseCurrency;\n  enrichedData.original_currency = docCurrency;\n  enrichedData.subtotal_base = extracted.subtotal;\n  enrichedData.tax_base = extracted.tax;\n  enrichedData.total_base = extracted.total;\n}\n\n// ==================== 6. VALIDATE GL ACCOUNTS (NEW!) ====================\n\nconsole.log(\"\\n📊 Step 6: Validating GL accounts from Google Sheets...\");\n\nconst accountsToValidate = [];\n\nif (docType === 'invoice') {\n  accountsToValidate.push('Accounts Receivable', 'Sales Revenue');\n} else if (docType === 'bill') {\n  accountsToValidate.push('Accounts Payable');\n}\n\naccountsToValidate.forEach(accountName => {\n  if (!CHART_OF_ACCOUNTS[accountName]) {\n    validationResults.warnings.push(`Account \"${accountName}\" not found in chart of accounts`);\n    validationResults.flags.push('ACCOUNT_MISSING');\n  } else {\n    console.log(`✓ Account \"${accountName}\" exists in COA (Balance: ${CHART_OF_ACCOUNTS[accountName].balance})`);\n  }\n});\n\nif (accountsToValidate.length > 0) {\n  validationResults.enrichments_applied.push('ACCOUNTS_VALIDATED_FROM_GOOGLE_SHEETS');\n}\n\n// ==================== 7. ADDITIONAL VALIDATIONS ====================\n\nconsole.log(\"\\n✅ Step 7: Additional validations...\");\n\n// Required fields\nconst requiredFields = ['doc_type', 'doc_number', 'issue_date', 'total'];\nrequiredFields.forEach(field => {\n  if (!extracted[field]) {\n    validationResults.errors.push(`Missing required field: ${field}`);\n    validationResults.is_valid = false;\n  }\n});\n\n// Date validations\nif (extracted.issue_date) {\n  const issueDate = new Date(extracted.issue_date);\n  const today = new Date();\n  \n  if (issueDate > today) {\n    validationResults.warnings.push(`Issue date is in the future: ${extracted.issue_date}`);\n    validationResults.flags.push('FUTURE_DATE');\n  }\n}\n\n// Amount validations\nif (extracted.total && extracted.total < 0) {\n  validationResults.errors.push('Total cannot be negative');\n  validationResults.is_valid = false;\n}\n\nif (enrichedData.total_base && enrichedData.total_base > 1000000) {\n  validationResults.warnings.push(`Very large amount: ${enrichedData.base_currency} ${enrichedData.total_base.toLocaleString()}`);\n  validationResults.flags.push('LARGE_AMOUNT');\n}\n\n// Credit limit check\nif (partyInfo && partyInfo.credit_limit && docType === 'invoice') {\n  if (enrichedData.total_base > partyInfo.credit_limit) {\n    validationResults.warnings.push(\n      `Amount (${enrichedData.total_base}) exceeds customer credit limit (${partyInfo.credit_limit})`\n    );\n    validationResults.flags.push('CREDIT_LIMIT_EXCEEDED');\n  }\n}\n\n// ==================== 8. STORE NORMALIZED VALUES ====================\n\nconsole.log(\"\\n💾 Step 8: Storing normalized values...\");\n\nconst normalizedValues = {\n  // Amounts (best available values)\n  subtotal: enrichedData.subtotal_normalized,\n  tax: enrichedData.tax_normalized,\n  tax_rate: enrichedData.tax_rate_normalized,\n  total: enrichedData.total_normalized,\n  \n  // Base currency amounts (for reporting)\n  subtotal_base: enrichedData.subtotal_base,\n  tax_base: enrichedData.tax_base,\n  total_base: enrichedData.total_base,\n  base_currency: enrichedData.base_currency,\n  \n  // Party information (from Google Sheets)\n  party_id: enrichedData.party_id,\n  party_type: enrichedData.party_type,\n  party_name: enrichedData.party_name,\n  party_tax_id: enrichedData.party_tax_id,\n  \n  // Flags\n  has_fx_conversion: docCurrency !== baseCurrency,\n  has_recalculated_totals: validationResults.enrichments_applied.includes('TOTAL_RECALCULATED'),\n  has_inferred_tax: validationResults.enrichments_applied.includes('TAX_INFERRED'),\n  is_duplicate: enrichedData.duplicate_found || false,\n  data_source: 'google_sheets'\n};\n\n// ==================== 9. FINAL SUMMARY ====================\n\nconst enrichmentSummary = {\n  enrichments_applied: validationResults.enrichments_applied.length,\n  enrichment_types: validationResults.enrichments_applied,\n  validation_status: validationResults.is_valid ? 'valid' : 'invalid',\n  total_errors: validationResults.errors.length,\n  total_warnings: validationResults.warnings.length,\n  total_flags: validationResults.flags.length,\n  requires_review: !validationResults.is_valid || validationResults.warnings.length > 2 || enrichedData.duplicate_found,\n  processing_status: validationResults.is_valid ? 'ready_for_posting' : 'needs_review',\n  data_source: 'google_sheets',\n  google_sheets_stats: masterData.stats,\n  enriched_at: new Date().toISOString()\n};\n\nconsole.log(\"\\n\" + \"=\".repeat(80));\nconsole.log(\"=== ENRICHMENT SUMMARY ===\");\nconsole.log(\"Data Source: Google Sheets ✅\");\nconsole.log(\"Enrichments applied:\", enrichmentSummary.enrichments_applied);\nconsole.log(\"Types:\", enrichmentSummary.enrichment_types.join(', '));\nconsole.log(\"Errors:\", enrichmentSummary.total_errors);\nconsole.log(\"Warnings:\", enrichmentSummary.total_warnings);\nconsole.log(\"Flags:\", validationResults.flags.join(', ') || 'None');\nconsole.log(\"Status:\", enrichmentSummary.processing_status);\nconsole.log(\"Duplicate Found:\", enrichedData.duplicate_found ? \"YES ❌\" : \"NO ✓\");\nconsole.log(\"=\"*80);\nconsole.log(\"✅ Validation & Enrichment complete (Google Sheets powered)!\");\n\n// ==================== RETURN ====================\n\nreturn {\n  json: {\n    // Preserve ensemble data\n    ...$json,\n    \n    // Add enriched extracted data\n    extracted_enriched: enrichedData,\n    \n    // Add normalized values (clean, ready for posting)\n    normalized: normalizedValues,\n    \n    // Validation results\n    validation: validationResults,\n    \n    // Summary\n    enrichment_summary: enrichmentSummary\n  }\n};"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        4016,
        608
      ],
      "id": "63b0b033-2b24-4716-99fc-c47dafce1444",
      "name": "Validation & Enrichment"
    },
    {
      "parameters": {
        "mode": "runOnceForEachItem",
        "jsCode": "// @ts-nocheck\n// Master CSV Export Coordinator (Google Sheets Enhanced)\n// Routes documents to appropriate CSV format and appends to Google Sheets\n\nconsole.log(\"=== CSV EXPORT COORDINATOR (GOOGLE SHEETS) ===\");\n\nconst extracted = $json.extracted || {};\nconst normalized = $json.normalized || {};\nconst extracted_enriched = $json.extracted_enriched || {};\nconst enrichment = $json.enrichment_summary || {};\nconst validation = $json.validation || {};\n\nconst docType = extracted.doc_type || 'unknown';\nconst currency = extracted_enriched.original_currency || extracted.currency || 'MYR';\nconst isForeignCurrency = currency !== 'MYR';\nconst isDuplicate = extracted_enriched.duplicate_found || false;\n\nconsole.log(\"Document Type:\", docType);\nconsole.log(\"Currency:\", currency);\nconsole.log(\"Foreign Currency:\", isForeignCurrency);\nconsole.log(\"Is Duplicate:\", isDuplicate);\nconsole.log(\"Processing Status:\", enrichment.processing_status);\n\n// Get master data for enrichment\nlet masterData;\ntry {\n  masterData = $('Build Master Data from Google Sheets').first().json;\n  console.log(\"✅ Master data available for export enrichment\");\n} catch (error) {\n  console.log(\"⚠️  Master data not available, using extracted data only\");\n  masterData = null;\n}\n\n// Initialize export records\nconst exports = {\n  supplier_invoice: null,\n  sales_order: null,\n  fx_bill: null,\n  mixed_doc: null,\n  bank_transaction: null // NEW: For payment tracking\n};\n\n// ==================== SUPPLIER INVOICES (Bills from Vendors) ====================\n\nif (docType === 'bill' || (docType === 'invoice' && extracted.vendor)) {\n  const vendorName = extracted.vendor || extracted_enriched.party_name || 'Unknown';\n  const invoiceNo = extracted.doc_number || '';\n  const subtotal = normalized.subtotal || extracted.subtotal || 0;\n  const taxRate = normalized.tax_rate || extracted.tax_rate || 0;\n  const total = normalized.total || extracted.total || 0;\n  \n  // Get GL Hint (enhanced with Google Sheets data)\n  let glHint = 'General Expense';\n  \n  // First try from extraction\n  if (extracted.line_items && extracted.line_items.length > 0) {\n    const firstItem = extracted.line_items[0];\n    if (firstItem.gl_hint) {\n      glHint = firstItem.gl_hint.replace(/^(Asset|Expense|COGS|Tax): /, '');\n    }\n  }\n  \n  // Then check if vendor has GL hint from Google Sheets\n  if (masterData && extracted_enriched.party_id) {\n    const vendorMaster = masterData.vendor_master || {};\n    const vendorInfo = Object.values(vendorMaster).find(v => v.id === extracted_enriched.party_id);\n    if (vendorInfo && vendorInfo.gl_hints && vendorInfo.gl_hints.length > 0) {\n      glHint = vendorInfo.gl_hints[0]; // Use vendor's typical GL category\n      console.log(\"  Using GL hint from vendor master:\", glHint);\n    }\n  }\n  \n  exports.supplier_invoice = {\n    'Vendor Name': vendorName,\n    'Invoice No.': invoiceNo,\n    'Subtotal': +subtotal.toFixed(2),\n    'Tax %': taxRate ? +(taxRate * 100).toFixed(2) : 0,\n    'Total': +total.toFixed(2),\n    'GL Hint': glHint,\n    'Status': isDuplicate ? 'Duplicate' : 'New', // NEW: Flag duplicates\n    'Party ID': extracted_enriched.party_id || '', // NEW: Link to master\n    'Processing Date': new Date().toISOString().split('T')[0] // NEW: Track when processed\n  };\n  \n  console.log(\"✓ Created Supplier Invoice record\");\n  if (isDuplicate) {\n    console.log(\"  ⚠️  Marked as DUPLICATE\");\n  }\n}\n\n// ==================== SALES ORDERS (Customer Invoices/Quotations) ====================\n\nif ((docType === 'invoice' || docType === 'quotation') && extracted.customer) {\n  const customerName = extracted.customer || extracted_enriched.party_name || 'Unknown';\n  const invoiceNumber = extracted.doc_number || '';\n  const total = normalized.total_base || normalized.total || extracted.total || 0;\n  \n  // Enhanced status determination\n  let status = 'Pending';\n  \n  if (isDuplicate) {\n    // Check original status from Google Sheets\n    if (extracted_enriched.duplicate_info) {\n      status = extracted_enriched.duplicate_info.original_status || 'Duplicate';\n    } else {\n      status = 'Duplicate';\n    }\n  } else if (docType === 'invoice') {\n    // Check if payment exists in bank statement\n    if (masterData && masterData.bank_statement) {\n      const matchingPayment = masterData.bank_statement.find(stmt => \n        stmt.Description && stmt.Description.toLowerCase().includes(customerName.toLowerCase())\n      );\n      \n      if (matchingPayment) {\n        const paymentAmount = Math.abs(matchingPayment.Amount || 0);\n        if (Math.abs(paymentAmount - total) < 1) {\n          status = 'Paid';\n          console.log(\"  ✓ Found matching payment in bank statement:\", matchingPayment['Reference ID']);\n        } else if (paymentAmount > 0 && paymentAmount < total) {\n          status = 'Partial';\n          console.log(\"  ⚠️  Partial payment found:\", paymentAmount, \"of\", total);\n        }\n      }\n    }\n    \n    // Fallback to enrichment status\n    if (status === 'Pending' && enrichment.processing_status === 'ready_for_posting') {\n      status = 'Ready';\n    }\n  } else if (docType === 'quotation') {\n    status = 'Quote';\n  }\n  \n  // Generate SO number (enhanced)\n  let soNumber = `SO-${invoiceNumber.replace(/[^0-9]/g, '') || '000'}`;\n  \n  // If duplicate, use original SO number\n  if (isDuplicate && extracted_enriched.duplicate_info && extracted_enriched.duplicate_info.so_number) {\n    soNumber = extracted_enriched.duplicate_info.so_number;\n    console.log(\"  Using original SO number:\", soNumber);\n  }\n  \n  exports.sales_order = {\n    'SO Number': soNumber,\n    'Customer Name': customerName,\n    'Invoice Number': invoiceNumber,\n    'Total': +total.toFixed(2),\n    'Status': status,\n    'Party ID': extracted_enriched.party_id || '', // NEW: Link to master\n    'Issue Date': extracted.issue_date || '', // NEW: Track date\n    'Due Date': extracted.due_date || '', // NEW: Track payment due\n    'Processing Date': new Date().toISOString().split('T')[0] // NEW\n  };\n  \n  console.log(\"✓ Created Sales Order record\");\n  console.log(\"  Status:\", status);\n  if (isDuplicate) {\n    console.log(\"  ⚠️  DUPLICATE - Using original SO:\", soNumber);\n  }\n}\n\n// ==================== FX BILLS (Foreign Currency) ====================\n\nif (isForeignCurrency) {\n  const vendor = extracted.vendor || extracted.customer || extracted_enriched.party_name || 'Unknown';\n  const amount = extracted.total || 0;\n  const fxRate = extracted_enriched.fx_rate || 1.0;\n  const convertedMYR = normalized.total_base || (amount * fxRate);\n  \n  // Check if FX rate came from Google Sheets\n  const fxSource = extracted_enriched.fx_rate_source || 'unknown';\n  \n  exports.fx_bill = {\n    'Vendor': vendor,\n    'Currency': currency,\n    'Amount': +amount.toFixed(2),\n    'FX Rate': +fxRate.toFixed(4),\n    'Converted MYR': +convertedMYR.toFixed(2),\n    'Rate Source': fxSource, // NEW: Track where rate came from\n    'Invoice No': extracted.doc_number || '', // NEW: Link to invoice\n    'Processing Date': new Date().toISOString().split('T')[0] // NEW\n  };\n  \n  console.log(\"✓ Created FX Bill record\");\n  console.log(\"  Rate:\", fxRate, \"from\", fxSource);\n}\n\n// ==================== BANK TRANSACTIONS (NEW!) ====================\n\n// Create bank transaction record for payment tracking\nif (docType === 'receipt' || (docType === 'invoice' && extracted.payment_reference)) {\n  const description = extracted.customer \n    ? `Payment from ${extracted.customer}` \n    : extracted.description || 'Payment received';\n  const amount = extracted.total || 0;\n  const refId = extracted.payment_reference || extracted.doc_number || '';\n  \n  exports.bank_transaction = {\n    'Date': extracted.issue_date || new Date().toISOString().split('T')[0],\n    'Description': description,\n    'Amount': +amount.toFixed(2),\n    'Reference ID': refId,\n    'Balance': null // To be updated by accounting system\n  };\n  \n  console.log(\"✓ Created Bank Transaction record\");\n}\n\n// ==================== MIXED DOCS (Classification Record) ====================\n\nconst fileName = $json.fileName || extracted.doc_number || 'unknown.pdf';\nconst confidence = extracted.extraction_confidence || \n                   $json.classification_confidence || \n                   0;\n\nexports.mixed_doc = {\n  'File Name': fileName,\n  'Predicted Type': docType.charAt(0).toUpperCase() + docType.slice(1).replace('_', ' '),\n  'Confidence': +confidence.toFixed(2),\n  'Is Duplicate': isDuplicate ? 'Yes' : 'No', // NEW\n  'Validation Status': validation.is_valid ? 'Valid' : 'Invalid', // NEW\n  'Processing Status': enrichment.processing_status || 'unknown', // NEW\n  'Warnings': validation.warnings ? validation.warnings.length : 0, // NEW\n  'Processed Date': new Date().toISOString().split('T')[0] // NEW\n};\n\nconsole.log(\"✓ Created Mixed Doc record\");\n\n// ==================== SUMMARY ====================\n\nconst exportSummary = {\n  has_supplier_invoice: exports.supplier_invoice !== null,\n  has_sales_order: exports.sales_order !== null,\n  has_fx_bill: exports.fx_bill !== null,\n  has_mixed_doc: exports.mixed_doc !== null,\n  has_bank_transaction: exports.bank_transaction !== null,\n  total_exports: Object.values(exports).filter(v => v !== null).length,\n  \n  // Enhanced metadata\n  document_type: docType,\n  is_duplicate: isDuplicate,\n  is_foreign_currency: isForeignCurrency,\n  validation_status: validation.is_valid ? 'valid' : 'invalid',\n  processing_status: enrichment.processing_status,\n  should_post: !isDuplicate && validation.is_valid,\n  data_source: 'google_sheets'\n};\n\nconsole.log(\"\\n=== EXPORT SUMMARY ===\");\nconsole.log(\"Supplier Invoice:\", exportSummary.has_supplier_invoice ? \"✓\" : \"✗\");\nconsole.log(\"Sales Order:\", exportSummary.has_sales_order ? \"✓\" : \"✗\");\nconsole.log(\"FX Bill:\", exportSummary.has_fx_bill ? \"✓\" : \"✗\");\nconsole.log(\"Bank Transaction:\", exportSummary.has_bank_transaction ? \"✓\" : \"✗\");\nconsole.log(\"Mixed Doc:\", exportSummary.has_mixed_doc ? \"✓\" : \"✗\");\nconsole.log(\"Total Exports:\", exportSummary.total_exports);\nconsole.log(\"\\nProcessing Decision:\");\nconsole.log(\"  Should Post:\", exportSummary.should_post ? \"YES ✓\" : \"NO ✗\");\nif (isDuplicate) {\n  console.log(\"  Reason: DUPLICATE DETECTED\");\n} else if (!validation.is_valid) {\n  console.log(\"  Reason: VALIDATION FAILED\");\n}\n\n// ==================== GOOGLE SHEETS UPDATE INSTRUCTIONS ====================\n\nconst sheetsUpdateInstructions = {\n  action: 'append_rows',\n  sheets_to_update: [],\n  \n  // Instructions for each export\n  supplier_invoices: exports.supplier_invoice ? {\n    sheet_name: 'Supplier_Invoices',\n    row_data: exports.supplier_invoice,\n    should_append: !isDuplicate // Only append if not duplicate\n  } : null,\n  \n  sales_orders: exports.sales_order ? {\n    sheet_name: 'Sales_Orders',\n    row_data: exports.sales_order,\n    should_append: !isDuplicate // Only append if not duplicate\n  } : null,\n  \n  fx_bills: exports.fx_bill ? {\n    sheet_name: 'FX_Bills',\n    row_data: exports.fx_bill,\n    should_append: true // Always log FX transactions\n  } : null,\n  \n  bank_statement: exports.bank_transaction ? {\n    sheet_name: 'Bank_Statement',\n    row_data: exports.bank_transaction,\n    should_append: true // Always log payments\n  } : null,\n  \n  mixed_docs: exports.mixed_doc ? {\n    sheet_name: 'Mixed_Docs',\n    row_data: exports.mixed_doc,\n    should_append: true // Always log all documents\n  } : null\n};\n\n// Build list of sheets to update\nif (sheetsUpdateInstructions.supplier_invoices?.should_append) {\n  sheetsUpdateInstructions.sheets_to_update.push('Supplier_Invoices');\n}\nif (sheetsUpdateInstructions.sales_orders?.should_append) {\n  sheetsUpdateInstructions.sheets_to_update.push('Sales_Orders');\n}\nif (sheetsUpdateInstructions.fx_bills?.should_append) {\n  sheetsUpdateInstructions.sheets_to_update.push('FX_Bills');\n}\nif (sheetsUpdateInstructions.bank_statement?.should_append) {\n  sheetsUpdateInstructions.sheets_to_update.push('Bank_Statement');\n}\nif (sheetsUpdateInstructions.mixed_docs?.should_append) {\n  sheetsUpdateInstructions.sheets_to_update.push('Mixed_Docs');\n}\n\nconsole.log(\"\\n=== GOOGLE SHEETS UPDATE PLAN ===\");\nconsole.log(\"Sheets to update:\", sheetsUpdateInstructions.sheets_to_update.join(', '));\nif (isDuplicate) {\n  console.log(\"⚠️  Note: Duplicate document - limited updates only\");\n}\n\n// ==================== RETURN ====================\n\nreturn {\n  json: {\n    ...$json,\n    csv_exports: exports,\n    export_summary: exportSummary,\n    google_sheets_instructions: sheetsUpdateInstructions\n  }\n};"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        4240,
        608
      ],
      "id": "918bb393-9683-45b9-a49c-af0f055740b4",
      "name": "CSV Export Coordinator"
    },
    {
      "parameters": {
        "documentId": {
          "__rl": true,
          "value": "1rE6cRZW9MrstGUURlnSIcGjLN2mIOwhCzajbY3k_Dy4",
          "mode": "id"
        },
        "sheetName": {
          "__rl": true,
          "value": 2104966662,
          "mode": "list",
          "cachedResultName": "Mixed_Docs",
          "cachedResultUrl": "https://docs.google.com/spreadsheets/d/1rE6cRZW9MrstGUURlnSIcGjLN2mIOwhCzajbY3k_Dy4/edit#gid=2104966662"
        },
        "options": {}
      },
      "type": "n8n-nodes-base.googleSheets",
      "typeVersion": 4.7,
      "position": [
        3792,
        32
      ],
      "id": "3dce9d87-0e94-4366-8838-9516c15f984c",
      "name": "Read Mixed Docs",
      "executeOnce": true,
      "credentials": {
        "googleSheetsOAuth2Api": {
          "id": "UyGfxGtg3Jm7hDky",
          "name": "Google Sheets account"
        }
      }
    },
    {
      "parameters": {
        "documentId": {
          "__rl": true,
          "value": "1rE6cRZW9MrstGUURlnSIcGjLN2mIOwhCzajbY3k_Dy4",
          "mode": "id"
        },
        "sheetName": {
          "__rl": true,
          "value": 458149216,
          "mode": "list",
          "cachedResultName": "Trial_Balance",
          "cachedResultUrl": "https://docs.google.com/spreadsheets/d/1rE6cRZW9MrstGUURlnSIcGjLN2mIOwhCzajbY3k_Dy4/edit#gid=458149216"
        },
        "options": {}
      },
      "type": "n8n-nodes-base.googleSheets",
      "typeVersion": 4.7,
      "position": [
        3792,
        -544
      ],
      "id": "2f1573b2-8902-4182-9461-dac558e2b42e",
      "name": "Read Trial Balance",
      "executeOnce": true,
      "credentials": {
        "googleSheetsOAuth2Api": {
          "id": "UyGfxGtg3Jm7hDky",
          "name": "Google Sheets account"
        }
      }
    },
    {
      "parameters": {
        "documentId": {
          "__rl": true,
          "value": "1rE6cRZW9MrstGUURlnSIcGjLN2mIOwhCzajbY3k_Dy4",
          "mode": "id"
        },
        "sheetName": {
          "__rl": true,
          "value": 547474527,
          "mode": "list",
          "cachedResultName": "FX_Bills",
          "cachedResultUrl": "https://docs.google.com/spreadsheets/d/1rE6cRZW9MrstGUURlnSIcGjLN2mIOwhCzajbY3k_Dy4/edit#gid=547474527"
        },
        "options": {}
      },
      "type": "n8n-nodes-base.googleSheets",
      "typeVersion": 4.7,
      "position": [
        3792,
        224
      ],
      "id": "cc0b67bb-0253-4d84-9905-7cf1438874b5",
      "name": "Read FX Bills",
      "executeOnce": true,
      "credentials": {
        "googleSheetsOAuth2Api": {
          "id": "UyGfxGtg3Jm7hDky",
          "name": "Google Sheets account"
        }
      }
    },
    {
      "parameters": {
        "documentId": {
          "__rl": true,
          "value": "1rE6cRZW9MrstGUURlnSIcGjLN2mIOwhCzajbY3k_Dy4",
          "mode": "id"
        },
        "sheetName": {
          "__rl": true,
          "value": 987266692,
          "mode": "list",
          "cachedResultName": "Supplier_Invoices",
          "cachedResultUrl": "https://docs.google.com/spreadsheets/d/1rE6cRZW9MrstGUURlnSIcGjLN2mIOwhCzajbY3k_Dy4/edit#gid=987266692"
        },
        "options": {}
      },
      "type": "n8n-nodes-base.googleSheets",
      "typeVersion": 4.7,
      "position": [
        3792,
        -160
      ],
      "id": "4d96745e-af4a-4029-8160-abf5aee537b4",
      "name": "Read Supplier Invoices",
      "executeOnce": true,
      "credentials": {
        "googleSheetsOAuth2Api": {
          "id": "UyGfxGtg3Jm7hDky",
          "name": "Google Sheets account"
        }
      }
    },
    {
      "parameters": {
        "documentId": {
          "__rl": true,
          "value": "1rE6cRZW9MrstGUURlnSIcGjLN2mIOwhCzajbY3k_Dy4",
          "mode": "id"
        },
        "sheetName": {
          "__rl": true,
          "value": 1530108956,
          "mode": "list",
          "cachedResultName": "Bank_Statement",
          "cachedResultUrl": "https://docs.google.com/spreadsheets/d/1rE6cRZW9MrstGUURlnSIcGjLN2mIOwhCzajbY3k_Dy4/edit#gid=1530108956"
        },
        "options": {}
      },
      "type": "n8n-nodes-base.googleSheets",
      "typeVersion": 4.7,
      "position": [
        3792,
        416
      ],
      "id": "236049d8-63bf-4efd-a991-2dbb0988221c",
      "name": "Read Bank Statement",
      "executeOnce": true,
      "credentials": {
        "googleSheetsOAuth2Api": {
          "id": "UyGfxGtg3Jm7hDky",
          "name": "Google Sheets account"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "// ============================================================================\n// NODE: \"Build Master Data from Google Sheets\"\n// Type: Code (JavaScript)\n// Mode: Run Once for All Items  ← IMPORTANT!\n// Depends on: 6 Google Sheets nodes that read each sheet\n// ============================================================================\n\n// This node combines data from all 6 Google Sheets read nodes and builds\n// master data structures for validation & enrichment\n// CRITICAL: This preserves input data from Ensemble Extraction!\n\nconsole.log(\"=== BUILDING MASTER DATA FROM GOOGLE SHEETS ===\");\n\n// ==================== GET DATA FROM GOOGLE SHEETS NODES ====================\n// Each Google Sheets node returns an array of items\n// We need to extract the JSON from each item\n\ntry {\n  var bankStatement = $('Read Bank Statement').all().map(item => item.json);\n  console.log(\"✓ Loaded Bank Statement:\", bankStatement.length, \"rows\");\n} catch (e) {\n  console.log(\"⚠️  Bank Statement node not found or not executed\");\n  var bankStatement = [];\n}\n\ntry {\n  var salesOrders = $('Read Sales Orders').all().map(item => item.json);\n  console.log(\"✓ Loaded Sales Orders:\", salesOrders.length, \"rows\");\n} catch (e) {\n  console.log(\"⚠️  Sales Orders node not found or not executed\");\n  var salesOrders = [];\n}\n\ntry {\n  var supplierInvoices = $('Read Supplier Invoices').all().map(item => item.json);\n  console.log(\"✓ Loaded Supplier Invoices:\", supplierInvoices.length, \"rows\");\n} catch (e) {\n  console.log(\"⚠️  Supplier Invoices node not found or not executed\");\n  var supplierInvoices = [];\n}\n\ntry {\n  var fxBills = $('Read FX Bills').all().map(item => item.json);\n  console.log(\"✓ Loaded FX Bills:\", fxBills.length, \"rows\");\n} catch (e) {\n  console.log(\"⚠️  FX Bills node not found or not executed\");\n  var fxBills = [];\n}\n\ntry {\n  var trialBalance = $('Read Trial Balance').all().map(item => item.json);\n  console.log(\"✓ Loaded Trial Balance:\", trialBalance.length, \"rows\");\n} catch (e) {\n  console.log(\"⚠️  Trial Balance node not found or not executed\");\n  var trialBalance = [];\n}\n\ntry {\n  var mixedDocs = $('Read Mixed Docs').all().map(item => item.json);\n  console.log(\"✓ Loaded Mixed Docs:\", mixedDocs.length, \"rows\");\n} catch (e) {\n  console.log(\"⚠️  Mixed Docs node not found or not executed\");\n  var mixedDocs = [];\n}\n\nconsole.log(\"\\n📊 Total data loaded from Google Sheets:\");\nconsole.log(\"  - Bank Statement:\", bankStatement.length, \"rows\");\nconsole.log(\"  - Sales Orders:\", salesOrders.length, \"rows\");\nconsole.log(\"  - Supplier Invoices:\", supplierInvoices.length, \"rows\");\nconsole.log(\"  - FX Bills:\", fxBills.length, \"rows\");\nconsole.log(\"  - Trial Balance:\", trialBalance.length, \"rows\");\nconsole.log(\"  - Mixed Docs:\", mixedDocs.length, \"rows\");\n\n// ==================== BUILD CUSTOMER MASTER ====================\nconsole.log(\"\\n🏢 Building Customer Master...\");\n\nconst customerMaster = {};\n\nsalesOrders.forEach((order) => {\n  const customerName = order['Customer Name'];\n  \n  if (!customerName) return;\n  \n  if (!customerMaster[customerName]) {\n    customerMaster[customerName] = {\n      id: `CUST${String(Object.keys(customerMaster).length + 1).padStart(3, '0')}`,\n      type: 'customer',\n      name: customerName,\n      currency: 'MYR',\n      tax_id: `C${String(Math.random()).substring(2, 10)}`,\n      payment_terms: '30 Days',\n      credit_limit: 100000,\n      status: 'active',\n      invoices: [],\n      total_revenue: 0,\n      paid_invoices: 0,\n      pending_invoices: 0\n    };\n  }\n  \n  // Add invoice to history\n  customerMaster[customerName].invoices.push({\n    invoice_number: order['Invoice Number'],\n    so_number: order['SO Number'],\n    total: parseFloat(order['Total']) || 0,\n    status: order['Status']\n  });\n  \n  // Update totals\n  customerMaster[customerName].total_revenue += parseFloat(order['Total']) || 0;\n  \n  if (order['Status'] === 'Paid') {\n    customerMaster[customerName].paid_invoices++;\n  } else {\n    customerMaster[customerName].pending_invoices++;\n  }\n});\n\nconsole.log(`✅ Built customer master: ${Object.keys(customerMaster).length} customers`);\nObject.keys(customerMaster).forEach(name => {\n  const c = customerMaster[name];\n  console.log(`   - ${name} (${c.id}): ${c.invoices.length} invoices, RM ${c.total_revenue.toFixed(2)}`);\n});\n\n// ==================== BUILD VENDOR MASTER ====================\nconsole.log(\"\\n🏭 Building Vendor Master...\");\n\nconst vendorMaster = {};\n\nsupplierInvoices.forEach((invoice) => {\n  const vendorName = invoice['Vendor Name'];\n  \n  if (!vendorName) return;\n  \n  if (!vendorMaster[vendorName]) {\n    vendorMaster[vendorName] = {\n      id: `VEND${String(Object.keys(vendorMaster).length + 1).padStart(3, '0')}`,\n      type: 'vendor',\n      name: vendorName,\n      currency: 'MYR',\n      tax_id: `V${String(Math.random()).substring(2, 10)}`,\n      payment_terms: 'Net 30',\n      status: 'active',\n      invoices: [],\n      total_purchases: 0,\n      gl_hints: []\n    };\n  }\n  \n  const total = parseFloat(invoice['Total']) || 0;\n  const subtotal = parseFloat(invoice['Subtotal']) || 0;\n  const taxPercent = parseFloat(invoice['Tax %']) || 0;\n  \n  // Add invoice to history\n  vendorMaster[vendorName].invoices.push({\n    invoice_number: invoice['Invoice No.'],\n    subtotal: subtotal,\n    tax_rate: taxPercent / 100,\n    total: total,\n    gl_hint: invoice['GL Hint']\n  });\n  \n  vendorMaster[vendorName].total_purchases += total;\n  \n  // Collect GL hints\n  const glHint = invoice['GL Hint'];\n  if (glHint && !vendorMaster[vendorName].gl_hints.includes(glHint)) {\n    vendorMaster[vendorName].gl_hints.push(glHint);\n  }\n});\n\nconsole.log(`✅ Built vendor master: ${Object.keys(vendorMaster).length} vendors`);\nObject.keys(vendorMaster).forEach(name => {\n  const v = vendorMaster[name];\n  console.log(`   - ${name} (${v.id}): ${v.invoices.length} invoices, RM ${v.total_purchases.toFixed(2)}`);\n});\n\n// ==================== BUILD FX RATES ====================\nconsole.log(\"\\n💱 Building FX Rates...\");\n\nconst fxRates = { MYR: 1.0 };\n\nfxBills.forEach(bill => {\n  const currency = bill['Currency'];\n  const rate = parseFloat(bill['FX Rate']);\n  \n  if (currency && rate && !fxRates[currency]) {\n    fxRates[currency] = rate;\n  }\n});\n\nconsole.log(`✅ Built FX rates: ${Object.keys(fxRates).length} currencies`);\nconsole.log(\"   Rates:\", JSON.stringify(fxRates, null, 2));\n\n// ==================== BUILD INVOICE HISTORY ====================\nconsole.log(\"\\n📋 Building Invoice History (for duplicate detection)...\");\n\nconst invoiceHistory = [];\n\n// Add customer invoices\nsalesOrders.forEach(order => {\n  if (order['Invoice Number']) {\n    invoiceHistory.push({\n      invoice_number: order['Invoice Number'],\n      so_number: order['SO Number'],\n      party_name: order['Customer Name'],\n      party_type: 'customer',\n      total: parseFloat(order['Total']) || 0,\n      status: order['Status'],\n      source: 'sales_order'\n    });\n  }\n});\n\n// Add supplier invoices\nsupplierInvoices.forEach(invoice => {\n  if (invoice['Invoice No.']) {\n    invoiceHistory.push({\n      invoice_number: invoice['Invoice No.'],\n      party_name: invoice['Vendor Name'],\n      party_type: 'vendor',\n      subtotal: parseFloat(invoice['Subtotal']) || 0,\n      total: parseFloat(invoice['Total']) || 0,\n      status: 'received',\n      source: 'supplier_invoice',\n      gl_hint: invoice['GL Hint']\n    });\n  }\n});\n\nconsole.log(`✅ Built invoice history: ${invoiceHistory.length} invoices`);\ninvoiceHistory.forEach(inv => {\n  console.log(`   - ${inv.invoice_number} (${inv.party_name}): RM ${inv.total}`);\n});\n\n// ==================== BUILD CHART OF ACCOUNTS ====================\nconsole.log(\"\\n📊 Building Chart of Accounts...\");\n\nconst chartOfAccounts = {};\n\ntrialBalance.forEach(account => {\n  const accountName = account['Account'];\n  if (accountName) {\n    chartOfAccounts[accountName] = {\n      name: accountName,\n      debit: parseFloat(account['Debit']) || 0,\n      credit: parseFloat(account['Credit']) || 0,\n      balance: parseFloat(account['Balance']) || 0,\n      exists: true\n    };\n  }\n});\n\nconsole.log(`✅ Built chart of accounts: ${Object.keys(chartOfAccounts).length} accounts`);\nObject.keys(chartOfAccounts).forEach(name => {\n  console.log(`   - ${name}: Balance RM ${chartOfAccounts[name].balance}`);\n});\n\n// ==================== COMBINE MASTERS ====================\nconst combinedMaster = {\n  ...customerMaster,\n  ...vendorMaster\n};\n\nconsole.log(\"\\n🔄 Combined Master:\");\nconsole.log(`   Total entities: ${Object.keys(combinedMaster).length}`);\nconsole.log(`   - Customers: ${Object.keys(customerMaster).length}`);\nconsole.log(`   - Vendors: ${Object.keys(vendorMaster).length}`);\n\n// ==================== RETURN MASTER DATA ====================\nconsole.log(\"\\n✅ MASTER DATA BUILD COMPLETE!\");\nconsole.log(\"   Data source: Google Sheets\");\nconsole.log(\"=\"*80);\n\n// ============================================================================\n// CRITICAL: Preserve input data from Ensemble Extraction!\n// ============================================================================\nreturn [{\n  json: {\n    // ✅ PRESERVE ALL INPUT DATA (from Ensemble Extraction)\n    // This includes: extracted, doc_type, text, sources, hash_key, etc.\n    ...$input.first().json,\n    \n    // ✅ ADD MASTER DATA STRUCTURES\n    customer_master: customerMaster,\n    vendor_master: vendorMaster,\n    combined_master: combinedMaster,\n    \n    // ✅ ADD SUPPORTING DATA\n    fx_rates: fxRates,\n    invoice_history: invoiceHistory,\n    chart_of_accounts: chartOfAccounts,\n    bank_statement: bankStatement,\n    \n    // ✅ ADD STATISTICS\n    stats: {\n      total_customers: Object.keys(customerMaster).length,\n      total_vendors: Object.keys(vendorMaster).length,\n      total_entities: Object.keys(combinedMaster).length,\n      total_invoices: invoiceHistory.length,\n      total_currencies: Object.keys(fxRates).length,\n      total_accounts: Object.keys(chartOfAccounts).length,\n      bank_transactions: bankStatement.length,\n      loaded_at: new Date().toISOString(),\n      data_source: 'google_sheets'\n    }\n  }\n}];"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        3792,
        608
      ],
      "id": "dab6d9ee-d267-4c33-a823-9f5711afd949",
      "name": "Build Master Data from Google Sheets"
    },
    {
      "parameters": {
        "documentId": {
          "__rl": true,
          "value": "1rE6cRZW9MrstGUURlnSIcGjLN2mIOwhCzajbY3k_Dy4",
          "mode": "id"
        },
        "sheetName": {
          "__rl": true,
          "value": 186307765,
          "mode": "list",
          "cachedResultName": "Sales_Orders",
          "cachedResultUrl": "https://docs.google.com/spreadsheets/d/1rE6cRZW9MrstGUURlnSIcGjLN2mIOwhCzajbY3k_Dy4/edit#gid=186307765"
        },
        "options": {}
      },
      "type": "n8n-nodes-base.googleSheets",
      "typeVersion": 4.7,
      "position": [
        3792,
        -352
      ],
      "id": "628468e9-d92b-43fd-8b73-79caf22996d0",
      "name": "Read Sales Orders",
      "executeOnce": true,
      "credentials": {
        "googleSheetsOAuth2Api": {
          "id": "UyGfxGtg3Jm7hDky",
          "name": "Google Sheets account"
        }
      }
    },
    {
      "parameters": {
        "mode": "runOnceForEachItem",
        "jsCode": "// @ts-nocheck\n// Module 5: Posting Engine (Double-Entry Bookkeeping) + AR/AP Aging\n// Generates journal entries following accounting principles and computes AR/AP aging\n\nconsole.log(\"=== POSTING ENGINE (DOUBLE-ENTRY) + AGING ===\");\n\nconst extracted = $json.extracted || {};\nconst normalized = $json.normalized || {};\nconst extracted_enriched = $json.extracted_enriched || {};\nconst validation = $json.validation || {};\n\nconst docType = (extracted.doc_type || 'unknown').toLowerCase();\nconst docNumber = extracted.doc_number || '';\nconst issueDate = extracted.issue_date || new Date().toISOString().split('T')[0];\nconst isDuplicate = !!(extracted_enriched.duplicate_found);\nconst isValid = validation.is_valid !== false;\n\nconsole.log(\"Document Type:\", docType);\nconsole.log(\"Document Number:\", docNumber);\nconsole.log(\"Is Duplicate:\", isDuplicate);\nconsole.log(\"Is Valid:\", isValid);\n\n// ==================== SKIP IF DUPLICATE OR INVALID ====================\n\nif (isDuplicate) {\n  console.log(\"⚠️  SKIPPING: Document is a duplicate\");\n  return {\n    json: {\n      ...$json,\n      journal_entries: [],\n      posting_summary: {\n        posted: false,\n        reason: 'duplicate',\n        entries_created: 0\n      }\n    }\n  };\n}\n\nif (!isValid) {\n  console.log(\"⚠️  SKIPPING: Document failed validation\");\n  return {\n    json: {\n      ...$json,\n      journal_entries: [],\n      posting_summary: {\n        posted: false,\n        reason: 'validation_failed',\n        entries_created: 0\n      }\n    }\n  };\n}\n\n// ==================== EXTRACT AMOUNTS ====================\n\nconst subtotal = normalized.subtotal_base ?? normalized.subtotal ?? 0;\nconst tax = normalized.tax_base ?? normalized.tax ?? 0;\nconst total = normalized.total_base ?? normalized.total ?? 0;\nconst shipping = extracted.shipping ?? 0;\nconst fxRate = extracted_enriched.fx_rate || 1.0;\nconst baseCurrency = extracted_enriched.base_currency || 'MYR';\n\nconsole.log(\"\\n💰 Amounts:\");\nconsole.log(\"  Subtotal:\", subtotal);\nconsole.log(\"  Tax:\", tax);\nconsole.log(\"  Shipping:\", shipping);\nconsole.log(\"  Total:\", total);\nconsole.log(\"  FX Rate:\", fxRate);\nconsole.log(\"  Base Currency:\", baseCurrency);\n\n// ==================== HELPERS (AGING) ====================\n\nconst todayISO = new Date().toISOString().slice(0,10);\n\nconst safeDate = (s) => {\n  if (!s) return null;\n  const d = new Date(s);\n  return isNaN(d.getTime()) ? null : d;\n};\n\n// Very lightweight payment term parser:\n// - \"30\", \"30 days\", \"net 30\", \"due in 45\" -> +N days\n// - \"eom 30\" treated as +30 (simple)\nfunction parsePaymentTermDays(term) {\n  if (!term) return null;\n  const t = String(term).toLowerCase();\n  const m = t.match(/(\\d{1,3})/);\n  if (m) return Number(m[1]);\n  return null;\n}\n\nfunction computeDueDate(issue, explicitDue, paymentTerm) {\n  // 1) explicit due_date wins\n  const dDue = safeDate(explicitDue);\n  if (dDue) return dDue;\n\n  // 2) parse payment_term days\n  const dIssue = safeDate(issue) || new Date();\n  const days = parsePaymentTermDays(paymentTerm);\n  if (Number.isFinite(days)) {\n    const d = new Date(dIssue);\n    d.setDate(d.getDate() + days);\n    return d;\n  }\n\n  // 3) fallback: treat issue date as due date\n  return dIssue;\n}\n\nfunction diffDays(a, b) {\n  const MS = 1000 * 60 * 60 * 24;\n  return Math.floor((a - b) / MS);\n}\n\nfunction toBucket(days) {\n  if (days <= 30) return '0-30';\n  if (days <= 60) return '31-60';\n  if (days <= 90) return '61-90';\n  return '90+';\n}\n\n// ==================== INITIALIZE JOURNAL ENTRIES ====================\n\nconst journalEntries = [];\nlet jeCounter = 1;\n\n// Generate unique JE ID\nconst generateJeId = () => {\n  const id = `JE-${docNumber || 'NOID'}-${jeCounter}`;\n  jeCounter++;\n  return id;\n};\n\n// Helper to add journal entry\nconst addJournalEntry = (account, debit, credit, memo) => {\n  journalEntries.push({\n    je_id: generateJeId(),\n    date: issueDate,\n    doc_id: docNumber,\n    account: account,\n    debit: debit ? +Number(debit).toFixed(2) : 0,\n    credit: credit ? +Number(credit).toFixed(2) : 0,\n    memo: memo || `${docType} - ${docNumber}`,\n    fx_rate: fxRate,\n    base_amount: debit ? +Number(debit).toFixed(2) : +Number(credit).toFixed(2)\n  });\n};\n\n// ==================== POSTING LOGIC BY DOCUMENT TYPE ====================\n\nconsole.log(\"\\n📊 Generating journal entries for:\", docType);\n\nlet ar_aging_entry = null;\nlet ap_aging_entry = null;\n\nif (docType === 'bill' || (docType === 'invoice' && extracted.vendor)) {\n  // ==================== SUPPLIER INVOICE (BILL / AP) ====================\n  console.log(\"Creating entries for SUPPLIER INVOICE...\");\n  \n  const vendorName = extracted.vendor || extracted_enriched.party_name || 'Unknown Vendor';\n\n  // Determine expense account from GL hint\n  let expenseAccount = 'General Expense';\n  if (Array.isArray(extracted.line_items) && extracted.line_items.length > 0) {\n    const firstItem = extracted.line_items[0];\n    if (firstItem && firstItem.gl_hint) expenseAccount = firstItem.gl_hint;\n  }\n  if (extracted_enriched.party_id && $json.vendor_master) {\n    const vendorInfo = Object.values($json.vendor_master).find(v => v.id === extracted_enriched.party_id);\n    if (vendorInfo && vendorInfo.gl_hints && vendorInfo.gl_hints.length > 0) {\n      expenseAccount = vendorInfo.gl_hints[0];\n    }\n  }\n  \n  console.log(\"  Expense Account:\", expenseAccount);\n  console.log(\"  Vendor:\", vendorName);\n  \n  // Entry 1: Dr Expense/Asset\n  addJournalEntry(expenseAccount, subtotal, 0, `Purchase from ${vendorName}`);\n  \n  // Entry 2: Dr Input Tax (if any)\n  if (tax > 0) {\n    addJournalEntry('Input Tax', tax, 0, `Tax on purchase from ${vendorName}`);\n  }\n  \n  // Entry 3: Cr Accounts Payable\n  addJournalEntry('Accounts Payable', 0, total, `Amount due to ${vendorName}`);\n  console.log(\"✓ Created supplier invoice entries\");\n\n  // ===== AP AGING ENTRY =====\n  const due = computeDueDate(issueDate, extracted.due_date, extracted.payment_term);\n  const now = new Date();\n  const days_outstanding = Math.max(0, diffDays(now, due));\n  const aging_bucket = toBucket(days_outstanding);\n\n  ap_aging_entry = {\n    doc_type: 'bill',\n    party_type: 'vendor',\n    vendor: vendorName,\n    bill_number: docNumber,\n    issue_date: issueDate,\n    due_date: due.toISOString().slice(0,10),\n    amount: +Number(total).toFixed(2),\n    amount_outstanding: +Number(total).toFixed(2), // simple: full amount (allocate later in reconciliation)\n    days_outstanding,\n    aging_bucket,\n    currency: baseCurrency,\n    status: 'received'\n  };\n\n} else if ((docType === 'invoice' || docType === 'quotation') && extracted.customer) {\n  // ==================== CUSTOMER INVOICE / AR ====================\n  const customerName = extracted.customer || extracted_enriched.party_name || 'Unknown Customer';\n  console.log(\"  Customer:\", customerName);\n\n  if (docType === 'quotation') {\n    console.log(\"⚠️  Note: Quotation - no journal entries posted (not yet invoiced)\");\n    return {\n      json: {\n        ...$json,\n        journal_entries: [],\n        posting_summary: {\n          posted: false,\n          reason: 'quotation_not_posted',\n          message: 'Quotations are not posted until converted to invoices',\n          entries_created: 0\n        },\n        ar_aging_entry: null,\n        ap_aging_entry: null\n      }\n    };\n  }\n\n  // Entry 1: Dr Accounts Receivable\n  addJournalEntry('Accounts Receivable', total, 0, `Invoice to ${customerName}`);\n  // Entry 2: Cr Sales Revenue\n  addJournalEntry('Sales Revenue', 0, subtotal, `Sales to ${customerName}`);\n  // Entry 3: Cr Output Tax (if any)\n  if (tax > 0) addJournalEntry('Output Tax', 0, tax, `Tax on sales to ${customerName}`);\n  console.log(\"✓ Created customer invoice entries\");\n\n  // ===== AR AGING ENTRY =====\n  const due = computeDueDate(issueDate, extracted.due_date, extracted.payment_term);\n  const now = new Date();\n  const days_outstanding = Math.max(0, diffDays(now, due));\n  const aging_bucket = toBucket(days_outstanding);\n\n  ar_aging_entry = {\n    doc_type: 'invoice',\n    party_type: 'customer',\n    customer: customerName,\n    invoice_number: docNumber,\n    issue_date: issueDate,\n    due_date: due.toISOString().slice(0,10),\n    amount: +Number(total).toFixed(2),\n    amount_outstanding: +Number(total).toFixed(2), // simple: full amount (apply allocations in reconciliation)\n    days_outstanding,\n    aging_bucket,\n    currency: baseCurrency,\n    status: 'pending' // will be refined by reconciliation if partial/paid\n  };\n\n} else if (docType === 'receipt') {\n  // ==================== RECEIPT (Payment Received) ====================\n  console.log(\"Creating entries for RECEIPT...\");\n  const customerName = extracted.customer || extracted_enriched.party_name || 'Unknown Customer';\n  addJournalEntry('Cash', total, 0, `Payment received from ${customerName}`);\n  addJournalEntry('Accounts Receivable', 0, total, `Payment allocation - ${customerName}`);\n  console.log(\"✓ Created receipt entries\");\n  // No AR aging entry here — handled when computing residuals at reconciliation\n\n} else if (docType === 'payment' || docType === 'bill_payment') {\n  // ==================== PAYMENT (to Vendor) ====================\n  console.log(\"Creating entries for PAYMENT...\");\n  const vendorName = extracted.vendor || extracted_enriched.party_name || 'Unknown Vendor';\n  addJournalEntry('Accounts Payable', total, 0, `Payment to ${vendorName}`);\n  addJournalEntry('Cash', 0, total, `Payment made to ${vendorName}`);\n  console.log(\"✓ Created payment entries\");\n  // No AP aging entry here — handled when computing residuals at reconciliation\n\n} else if (docType === 'credit_note') {\n  // ==================== CREDIT NOTE (Sales Return) ====================\n  console.log(\"Creating entries for CREDIT NOTE...\");\n  const customerName = extracted.customer || extracted_enriched.party_name || 'Unknown Customer';\n  addJournalEntry('Sales Returns', subtotal, 0, `Credit note to ${customerName}`);\n  if (tax > 0) addJournalEntry('Output Tax', tax, 0, `Tax reversal - credit note to ${customerName}`);\n  addJournalEntry('Accounts Receivable', 0, total, `Credit note - ${customerName}`);\n  console.log(\"✓ Created credit note entries\");\n  // No new AR aging entry here (it offsets AR)\n\n} else if (docType === 'debit_note') {\n  // ==================== DEBIT NOTE (Purchase Return) ====================\n  console.log(\"Creating entries for DEBIT NOTE...\");\n  const vendorName = extracted.vendor || extracted_enriched.party_name || 'Unknown Vendor';\n  addJournalEntry('Accounts Payable', total, 0, `Debit note - ${vendorName}`);\n  addJournalEntry('Purchase Returns', 0, subtotal, `Return to ${vendorName}`);\n  if (tax > 0) addJournalEntry('Input Tax', 0, tax, `Tax reversal - return to ${vendorName}`);\n  console.log(\"✓ Created debit note entries\");\n  // No new AP aging entry here (it offsets AP)\n\n} else {\n  // ==================== UNKNOWN DOCUMENT TYPE ====================\n  console.log(\"⚠️  Unknown document type - no posting rules defined\");\n  return {\n    json: {\n      ...$json,\n      journal_entries: [],\n      posting_summary: {\n        posted: false,\n        reason: 'unknown_document_type',\n        entries_created: 0\n      },\n      ar_aging_entry: null,\n      ap_aging_entry: null\n    }\n  };\n}\n\n// ==================== VALIDATE BALANCE ====================\n\nconsole.log(\"\\n⚖️  Validating journal entries...\");\n\nconst totalDebits = journalEntries.reduce((sum, entry) => sum + (entry.debit || 0), 0);\nconst totalCredits = journalEntries.reduce((sum, entry) => sum + (entry.credit || 0), 0);\nconst isBalanced = Math.abs(totalDebits - totalCredits) < 0.01;\n\nconsole.log(\"  Total Debits:\", totalDebits.toFixed(2));\nconsole.log(\"  Total Credits:\", totalCredits.toFixed(2));\nconsole.log(\"  Difference:\", (totalDebits - totalCredits).toFixed(2));\nconsole.log(\"  Balanced:\", isBalanced ? \"✓ YES\" : \"✗ NO\");\n\nif (!isBalanced) console.log(\"❌ ERROR: Journal entries are not balanced!\");\n\n// ==================== SUMMARY ====================\n\nconst postingSummary = {\n  posted: isBalanced,\n  doc_type: docType,\n  doc_number: docNumber,\n  doc_date: issueDate,\n  entries_created: journalEntries.length,\n  total_debits: +totalDebits.toFixed(2),\n  total_credits: +totalCredits.toFixed(2),\n  is_balanced: isBalanced,\n  balance_difference: +(totalDebits - totalCredits).toFixed(2),\n  base_currency: baseCurrency,\n  fx_rate: fxRate,\n  posted_at: new Date().toISOString()\n};\n\nconsole.log(\"\\n\" + \"=\".repeat(80));\nconsole.log(\"=== POSTING SUMMARY ===\");\nconsole.log(\"Document:\", docNumber, `(${docType})`);\nconsole.log(\"Entries Created:\", journalEntries.length);\nconsole.log(\"Total Debits:\", totalDebits.toFixed(2), baseCurrency);\nconsole.log(\"Total Credits:\", totalCredits.toFixed(2), baseCurrency);\nconsole.log(\"Status:\", isBalanced ? \"✓ POSTED\" : \"✗ UNBALANCED\");\nconsole.log(\"=\".repeat(80));\n\n// ==================== DISPLAY JOURNAL ENTRIES ====================\n\nconsole.log(\"\\n📖 Journal Entries:\");\nconsole.log(\"-\".repeat(80));\njournalEntries.forEach(entry => {\n  const dr = entry.debit > 0 ? `Dr ${entry.debit.toFixed(2)}` : '';\n  const cr = entry.credit > 0 ? `Cr ${entry.credit.toFixed(2)}` : '';\n  console.log(`${String(entry.account).padEnd(30)} ${dr.padEnd(15)} ${cr.padEnd(15)} ${entry.memo}`);\n});\nconsole.log(\"-\".repeat(80));\n\n// ==================== RETURN ====================\n\nreturn {\n  json: {\n    ...$json,\n    journal_entries: journalEntries,\n    posting_summary: postingSummary,\n    ar_aging_entry,\n    ap_aging_entry\n  }\n};\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        4464,
        608
      ],
      "id": "c035f2de-0ef3-488e-8fe8-f1689b4c1321",
      "name": "Posting Engine (Double Entry)"
    },
    {
      "parameters": {
        "mode": "runOnceForEachItem",
        "jsCode": "// @ts-nocheck\n// Module 6: Reconciliation & Lifecycle Engine\n// Handles bank feed matching, payment allocation, and AR/AP aging\n\nconsole.log(\"=== RECONCILIATION & LIFECYCLE ENGINE ===\");\n\nconst extracted = $json.extracted || {};\nconst normalized = $json.normalized || {};\nconst extracted_enriched = $json.extracted_enriched || {};\nconst journalEntries = $json.journal_entries || [];\nconst postingSummary = $json.posting_summary || {};\n\nconst docType = extracted.doc_type || 'unknown';\nconst docNumber = extracted.doc_number || '';\nconst issueDate = extracted.issue_date || new Date().toISOString().split('T')[0];\nconst total = normalized.total_base || normalized.total || 0;\nconst partyName = extracted_enriched.party_name || extracted.customer || extracted.vendor || '';\n\n// ==================== LOAD MASTER DATA ====================\n\nlet masterData;\ntry {\n  masterData = $('Build Master Data from Google Sheets').first().json;\n  console.log(\"✅ Master data loaded\");\n} catch (error) {\n  console.log(\"⚠️  Master data not available\");\n  masterData = null;\n}\n\nconst BANK_STATEMENT = masterData?.bank_statement || [];\nconst INVOICE_HISTORY = masterData?.invoice_history || [];\n\nconsole.log(\"Bank Statement Transactions:\", BANK_STATEMENT.length);\nconsole.log(\"Invoice History Records:\", INVOICE_HISTORY.length);\n\n// ==================== RECONCILIATION RESULTS ====================\n\nconst reconciliationResults = {\n  bank_matches: [],\n  payment_allocations: [],\n  outstanding_ar: [],\n  outstanding_ap: [],\n  ar_aging: {},\n  ap_aging: {},\n  reconciliation_summary: {}\n};\n\n// ==================== 1. BANK FEED MATCHING ====================\n\nconsole.log(\"\\n💳 Step 1: Bank Feed Matching...\");\n\nif (docType === 'invoice' && partyName) {\n  // Find matching bank payment for customer invoice\n  console.log(`  Looking for payment from: ${partyName}`);\n  \n  const matchingPayments = BANK_STATEMENT.filter(stmt => {\n    const description = stmt.Description || '';\n    const amount = Math.abs(stmt.Amount || 0);\n    \n    // Match by customer name and amount\n    const nameMatch = description.toLowerCase().includes(partyName.toLowerCase());\n    const amountMatch = Math.abs(amount - total) < 1; // Within RM 1\n    \n    return nameMatch && amount > 0; // Positive = money in\n  });\n  \n  if (matchingPayments.length > 0) {\n    matchingPayments.forEach(payment => {\n      const paymentAmount = Math.abs(payment.Amount || 0);\n      const isFullPayment = Math.abs(paymentAmount - total) < 1;\n      \n      const match = {\n        doc_number: docNumber,\n        doc_type: docType,\n        party_name: partyName,\n        invoice_amount: total,\n        payment_date: payment.Date,\n        payment_amount: paymentAmount,\n        payment_reference: payment['Reference ID'],\n        match_type: isFullPayment ? 'full' : 'partial',\n        remaining_balance: isFullPayment ? 0 : +(total - paymentAmount).toFixed(2),\n        matched_at: new Date().toISOString()\n      };\n      \n      reconciliationResults.bank_matches.push(match);\n      \n      console.log(`  ✓ Found ${match.match_type} payment: ${payment['Reference ID']}`);\n      console.log(`    Amount: RM ${paymentAmount}, Balance: RM ${match.remaining_balance}`);\n    });\n  } else {\n    console.log(`  ✗ No matching payment found`);\n  }\n  \n} else if (docType === 'bill' && partyName) {\n  // Find matching bank payment to vendor\n  console.log(`  Looking for payment to: ${partyName}`);\n  \n  const matchingPayments = BANK_STATEMENT.filter(stmt => {\n    const description = stmt.Description || '';\n    const amount = Math.abs(stmt.Amount || 0);\n    \n    // Match by vendor name and amount\n    const nameMatch = description.toLowerCase().includes(partyName.toLowerCase());\n    const amountMatch = Math.abs(amount - total) < 1;\n    \n    return nameMatch && amount > 0 && stmt.Amount < 0; // Negative = money out\n  });\n  \n  if (matchingPayments.length > 0) {\n    matchingPayments.forEach(payment => {\n      const paymentAmount = Math.abs(payment.Amount || 0);\n      const isFullPayment = Math.abs(paymentAmount - total) < 1;\n      \n      const match = {\n        doc_number: docNumber,\n        doc_type: docType,\n        party_name: partyName,\n        bill_amount: total,\n        payment_date: payment.Date,\n        payment_amount: paymentAmount,\n        payment_reference: payment['Reference ID'],\n        match_type: isFullPayment ? 'full' : 'partial',\n        remaining_balance: isFullPayment ? 0 : +(total - paymentAmount).toFixed(2),\n        matched_at: new Date().toISOString()\n      };\n      \n      reconciliationResults.bank_matches.push(match);\n      \n      console.log(`  ✓ Found ${match.match_type} payment: ${payment['Reference ID']}`);\n    });\n  } else {\n    console.log(`  ✗ No matching payment found`);\n  }\n}\n\n// ==================== 2. PAYMENT ALLOCATION ====================\n\nconsole.log(\"\\n💰 Step 2: Payment Allocation...\");\n\nif (reconciliationResults.bank_matches.length > 0) {\n  reconciliationResults.bank_matches.forEach(match => {\n    const allocation = {\n      invoice_number: match.doc_number,\n      party_name: match.party_name,\n      invoice_amount: match.invoice_amount || match.bill_amount,\n      payment_amount: match.payment_amount,\n      allocated_amount: match.payment_amount,\n      remaining_amount: match.remaining_balance,\n      allocation_date: match.payment_date,\n      payment_reference: match.payment_reference,\n      status: match.match_type === 'full' ? 'fully_paid' : 'partially_paid'\n    };\n    \n    reconciliationResults.payment_allocations.push(allocation);\n    \n    console.log(`  ✓ Allocated RM ${allocation.allocated_amount} to ${allocation.invoice_number}`);\n    console.log(`    Status: ${allocation.status}`);\n  });\n} else {\n  console.log(\"  No payments to allocate\");\n}\n\n// ==================== 3. OUTSTANDING AR (Accounts Receivable) ====================\n\nconsole.log(\"\\n📊 Step 3: Computing Outstanding AR...\");\n\nconst today = new Date();\n\n// Get all customer invoices\nconst customerInvoices = INVOICE_HISTORY.filter(inv => inv.party_type === 'customer');\n\nconsole.log(`  Found ${customerInvoices.length} customer invoices`);\n\ncustomerInvoices.forEach(invoice => {\n  // Check if paid in bank statement\n  const payment = BANK_STATEMENT.find(stmt => {\n    const description = stmt.Description || '';\n    return description.toLowerCase().includes(invoice.party_name.toLowerCase()) &&\n           Math.abs(Math.abs(stmt.Amount) - invoice.total) < 1;\n  });\n  \n  if (!payment && invoice.status !== 'Paid') {\n    // Outstanding invoice\n    const invoiceDate = new Date(invoice.issue_date || today);\n    const daysOutstanding = Math.floor((today - invoiceDate) / (1000 * 60 * 60 * 24));\n    \n    const outstanding = {\n      invoice_number: invoice.invoice_number,\n      so_number: invoice.so_number,\n      party_name: invoice.party_name,\n      invoice_date: invoice.issue_date || '',\n      due_date: invoice.due_date || '',\n      amount: invoice.total,\n      days_outstanding: daysOutstanding,\n      aging_bucket: getAgingBucket(daysOutstanding),\n      status: invoice.status || 'Pending'\n    };\n    \n    reconciliationResults.outstanding_ar.push(outstanding);\n  }\n});\n\nconsole.log(`  Outstanding AR: ${reconciliationResults.outstanding_ar.length} invoices`);\n\n// ==================== 4. OUTSTANDING AP (Accounts Payable) ====================\n\nconsole.log(\"\\n📊 Step 4: Computing Outstanding AP...\");\n\n// Get all vendor bills\nconst vendorBills = INVOICE_HISTORY.filter(inv => inv.party_type === 'vendor');\n\nconsole.log(`  Found ${vendorBills.length} vendor bills`);\n\nvendorBills.forEach(bill => {\n  // Check if paid in bank statement\n  const payment = BANK_STATEMENT.find(stmt => {\n    const description = stmt.Description || '';\n    return description.toLowerCase().includes(bill.party_name.toLowerCase()) &&\n           Math.abs(Math.abs(stmt.Amount) - bill.total) < 1 &&\n           stmt.Amount < 0; // Payment out\n  });\n  \n  if (!payment && bill.status !== 'paid') {\n    // Outstanding bill\n    const billDate = new Date(bill.issue_date || today);\n    const daysOutstanding = Math.floor((today - billDate) / (1000 * 60 * 60 * 24));\n    \n    const outstanding = {\n      invoice_number: bill.invoice_number,\n      party_name: bill.party_name,\n      bill_date: bill.issue_date || '',\n      due_date: bill.due_date || '',\n      amount: bill.total,\n      days_outstanding: daysOutstanding,\n      aging_bucket: getAgingBucket(daysOutstanding),\n      status: bill.status || 'unpaid',\n      gl_hint: bill.gl_hint\n    };\n    \n    reconciliationResults.outstanding_ap.push(outstanding);\n  }\n});\n\nconsole.log(`  Outstanding AP: ${reconciliationResults.outstanding_ap.length} bills`);\n\n// ==================== 5. AR AGING REPORT ====================\n\nconsole.log(\"\\n📈 Step 5: AR Aging Report...\");\n\nconst arAging = {\n  '0-30': { count: 0, amount: 0, invoices: [] },\n  '31-60': { count: 0, amount: 0, invoices: [] },\n  '61-90': { count: 0, amount: 0, invoices: [] },\n  '90+': { count: 0, amount: 0, invoices: [] },\n  total: { count: 0, amount: 0 }\n};\n\nreconciliationResults.outstanding_ar.forEach(inv => {\n  const bucket = inv.aging_bucket;\n  arAging[bucket].count++;\n  arAging[bucket].amount += inv.amount;\n  arAging[bucket].invoices.push(inv.invoice_number);\n  \n  arAging.total.count++;\n  arAging.total.amount += inv.amount;\n});\n\n// Round amounts\nObject.keys(arAging).forEach(key => {\n  arAging[key].amount = +arAging[key].amount.toFixed(2);\n});\n\nreconciliationResults.ar_aging = arAging;\n\nconsole.log(\"  AR Aging Summary:\");\nconsole.log(`    0-30 days:   ${arAging['0-30'].count} invoices, RM ${arAging['0-30'].amount}`);\nconsole.log(`    31-60 days:  ${arAging['31-60'].count} invoices, RM ${arAging['31-60'].amount}`);\nconsole.log(`    61-90 days:  ${arAging['61-90'].count} invoices, RM ${arAging['61-90'].amount}`);\nconsole.log(`    90+ days:    ${arAging['90+'].count} invoices, RM ${arAging['90+'].amount}`);\nconsole.log(`    Total:       ${arAging.total.count} invoices, RM ${arAging.total.amount}`);\n\n// ==================== 6. AP AGING REPORT ====================\n\nconsole.log(\"\\n📈 Step 6: AP Aging Report...\");\n\nconst apAging = {\n  '0-30': { count: 0, amount: 0, bills: [] },\n  '31-60': { count: 0, amount: 0, bills: [] },\n  '61-90': { count: 0, amount: 0, bills: [] },\n  '90+': { count: 0, amount: 0, bills: [] },\n  total: { count: 0, amount: 0 }\n};\n\nreconciliationResults.outstanding_ap.forEach(bill => {\n  const bucket = bill.aging_bucket;\n  apAging[bucket].count++;\n  apAging[bucket].amount += bill.amount;\n  apAging[bucket].bills.push(bill.invoice_number);\n  \n  apAging.total.count++;\n  apAging.total.amount += bill.amount;\n});\n\n// Round amounts\nObject.keys(apAging).forEach(key => {\n  apAging[key].amount = +apAging[key].amount.toFixed(2);\n});\n\nreconciliationResults.ap_aging = apAging;\n\nconsole.log(\"  AP Aging Summary:\");\nconsole.log(`    0-30 days:   ${apAging['0-30'].count} bills, RM ${apAging['0-30'].amount}`);\nconsole.log(`    31-60 days:  ${apAging['31-60'].count} bills, RM ${apAging['31-60'].amount}`);\nconsole.log(`    61-90 days:  ${apAging['61-90'].count} bills, RM ${apAging['61-90'].amount}`);\nconsole.log(`    90+ days:    ${apAging['90+'].count} bills, RM ${apAging['90+'].amount}`);\nconsole.log(`    Total:       ${apAging.total.count} bills, RM ${apAging.total.amount}`);\n\n// ==================== HELPER FUNCTION ====================\n\nfunction getAgingBucket(days) {\n  if (days <= 30) return '0-30';\n  if (days <= 60) return '31-60';\n  if (days <= 90) return '61-90';\n  return '90+';\n}\n\n// ==================== 7. RECONCILIATION SUMMARY ====================\n\nconst reconciliationSummary = {\n  doc_number: docNumber,\n  doc_type: docType,\n  party_name: partyName,\n  \n  // Bank matching\n  bank_matches_found: reconciliationResults.bank_matches.length,\n  fully_matched: reconciliationResults.bank_matches.filter(m => m.match_type === 'full').length,\n  partially_matched: reconciliationResults.bank_matches.filter(m => m.match_type === 'partial').length,\n  \n  // Payment allocation\n  payments_allocated: reconciliationResults.payment_allocations.length,\n  total_allocated: reconciliationResults.payment_allocations.reduce((sum, p) => sum + p.allocated_amount, 0),\n  \n  // Outstanding\n  total_ar_outstanding: arAging.total.amount,\n  total_ar_invoices: arAging.total.count,\n  total_ap_outstanding: apAging.total.amount,\n  total_ap_bills: apAging.total.count,\n  \n  // Status\n  is_reconciled: reconciliationResults.bank_matches.length > 0,\n  reconciliation_date: new Date().toISOString()\n};\n\nreconciliationResults.reconciliation_summary = reconciliationSummary;\n\nconsole.log(\"\\n\" + \"=\".repeat(80));\nconsole.log(\"=== RECONCILIATION SUMMARY ===\");\nconsole.log(\"Document:\", docNumber, `(${docType})`);\nconsole.log(\"Party:\", partyName);\nconsole.log(\"\\nBank Matching:\");\nconsole.log(\"  Matches Found:\", reconciliationSummary.bank_matches_found);\nconsole.log(\"  Full Matches:\", reconciliationSummary.fully_matched);\nconsole.log(\"  Partial Matches:\", reconciliationSummary.partially_matched);\nconsole.log(\"\\nPayment Allocation:\");\nconsole.log(\"  Payments Allocated:\", reconciliationSummary.payments_allocated);\nconsole.log(\"  Total Allocated: RM\", reconciliationSummary.total_allocated.toFixed(2));\nconsole.log(\"\\nOutstanding:\");\nconsole.log(\"  AR Outstanding: RM\", reconciliationSummary.total_ar_outstanding);\nconsole.log(\"  AP Outstanding: RM\", reconciliationSummary.total_ap_outstanding);\nconsole.log(\"\\nStatus:\", reconciliationSummary.is_reconciled ? \"✓ RECONCILED\" : \"○ NOT RECONCILED\");\nconsole.log(\"=\".repeat(80));\n\n// ==================== RETURN ====================\n\nreturn {\n  json: {\n    ...$json,\n    reconciliation: reconciliationResults,\n    reconciliation_summary: reconciliationSummary\n  }\n};"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        4688,
        608
      ],
      "id": "ab2bf42a-2870-4b9c-a4d6-2fd5670efc58",
      "name": "Reconciliation Engine"
    },
    {
      "parameters": {
        "mode": "runOnceForEachItem",
        "jsCode": "// @ts-nocheck\n// Module 7: Exceptions Desk (Human-in-Loop)\n// Flags low-confidence documents and routes to human review\n\nconsole.log(\"=== EXCEPTIONS DESK (HUMAN-IN-LOOP) ===\");\n\nconst extracted = $json.extracted || {};\nconst validation = $json.validation || {};\nconst enrichment = $json.enrichment_summary || {};\nconst reconciliation = $json.reconciliation_summary || {};\n\n// (optional) row/snapshot for write-back\nconst row = $json.row ? { ...$json.row } : null;\n\n// Try to parse snapshot_json if provided so we can persist review_message there too\nlet snap = null;\nif (typeof $json.snapshot_json === 'string' && $json.snapshot_json.trim()) {\n  try { snap = JSON.parse($json.snapshot_json); } catch { snap = null; }\n} else if ($json.snapshot_json && typeof $json.snapshot_json === 'object') {\n  snap = { ...$json.snapshot_json };\n}\n\nconst docType = extracted.doc_type || 'unknown';\nconst docNumber = extracted.doc_number || '';\nconst confidence = extracted.extraction_confidence || $json.confidence || 0;\n\n// ==================== EXCEPTION RULES ====================\n\nconst CONFIDENCE_THRESHOLD = 0.75;\nconst HIGH_CONFIDENCE_THRESHOLD = 0.85;\n\nconsole.log(\"Document:\", docNumber, `(${docType})`);\nconsole.log(\"Confidence:\", confidence.toFixed(2));\nconsole.log(\"Validation Status:\", validation.is_valid ? \"Valid\" : \"Invalid\");\nconsole.log(\"Processing Status:\", enrichment.processing_status);\n\n// ==================== DETERMINE IF EXCEPTION ====================\n\nconst exceptionReasons = [];\nconst exceptionSeverity = [];\nlet requiresReview = false;\n\n// 1. Low Confidence\nif (confidence < CONFIDENCE_THRESHOLD) {\n  exceptionReasons.push(`Low confidence: ${(confidence * 100).toFixed(0)}% (threshold: 75%)`);\n  exceptionSeverity.push('medium');\n  requiresReview = true;\n  console.log(\"⚠️  EXCEPTION: Low extraction confidence\");\n}\n\n// 2. Validation Errors\nif (!validation.is_valid) {\n  const errorCount = validation.errors ? validation.errors.length : 0;\n  exceptionReasons.push(`Validation failed: ${errorCount} error(s)`);\n  exceptionSeverity.push('high');\n  requiresReview = true;\n  console.log(\"⚠️  EXCEPTION: Validation errors present\");\n}\n\n// 3. Duplicate Detected\nif (enrichment.processing_status === 'needs_review' && \n    validation.flags && validation.flags.includes('DUPLICATE_DETECTED')) {\n  exceptionReasons.push('Duplicate document detected');\n  exceptionSeverity.push('high');\n  requiresReview = true;\n  console.log(\"⚠️  EXCEPTION: Duplicate detected\");\n}\n\n// 4. Missing Critical Fields\nconst missingFields = [];\nif (!extracted.doc_number) missingFields.push('doc_number');\nif (!extracted.issue_date) missingFields.push('issue_date');\nif (!extracted.total)      missingFields.push('total');\nif (!extracted.customer && !extracted.vendor) missingFields.push('customer/vendor');\n\nif (missingFields.length > 0) {\n  exceptionReasons.push(`Missing fields: ${missingFields.join(', ')}`);\n  exceptionSeverity.push('high');\n  requiresReview = true;\n  console.log(\"⚠️  EXCEPTION: Missing critical fields\");\n}\n\n// 5. Validation Warnings (Multiple)\nif (validation.warnings && validation.warnings.length > 2) {\n  exceptionReasons.push(`Multiple warnings: ${validation.warnings.length} issues`);\n  exceptionSeverity.push('low');\n  requiresReview = true;\n  console.log(\"⚠️  EXCEPTION: Multiple validation warnings\");\n}\n\n// 6. Large Amount\nconst total = extracted.total || 0;\nif (total > 50000) {\n  exceptionReasons.push(`Large amount: RM ${total.toLocaleString()}`);\n  exceptionSeverity.push('medium');\n  requiresReview = true;\n  console.log(\"⚠️  EXCEPTION: Large amount requires approval\");\n}\n\n// 7. Unknown Party\nif (validation.flags && validation.flags.includes('UNKNOWN_PARTY')) {\n  exceptionReasons.push('Party not found in master registry');\n  exceptionSeverity.push('medium');\n  requiresReview = true;\n  console.log(\"⚠️  EXCEPTION: Unknown party\");\n}\n\n// 8. Unbalanced Journal Entries\nif ($json.posting_summary && !$json.posting_summary.posted) {\n  const reason = $json.posting_summary.reason || 'unknown';\n  if (reason !== 'duplicate' && reason !== 'validation_failed' && reason !== 'quotation_not_posted') {\n    exceptionReasons.push('Journal entries unbalanced or failed to post');\n    exceptionSeverity.push('high');\n    requiresReview = true;\n    console.log(\"⚠️  EXCEPTION: Posting failed\");\n  }\n}\n\n// 9. Partial Payment (for monitoring)\nif (reconciliation && reconciliation.partially_matched > 0) {\n  exceptionReasons.push('Partial payment detected - requires follow-up');\n  exceptionSeverity.push('low');\n  // Note: Not requiring review, just flagging for monitoring\n  console.log(\"ℹ️  INFO: Partial payment detected\");\n}\n\n// ==================== DETERMINE SEVERITY ====================\n\nlet overallSeverity = 'none';\nif (exceptionSeverity.includes('high')) {\n  overallSeverity = 'high';\n} else if (exceptionSeverity.includes('medium')) {\n  overallSeverity = 'medium';\n} else if (exceptionSeverity.includes('low')) {\n  overallSeverity = 'low';\n}\n\n// ==================== BUILD EXCEPTION REPORT ====================\n\nconst exceptionReport = {\n  doc_number: docNumber,\n  doc_type: docType,\n  requires_review: requiresReview,\n  severity: overallSeverity,\n  exception_count: exceptionReasons.length,\n  exceptions: exceptionReasons,\n  \n  // Document details\n  confidence: confidence,\n  extraction_confidence: confidence,\n  validation_status: validation.is_valid ? 'valid' : 'invalid',\n  processing_status: enrichment.processing_status,\n  \n  // Key extracted data\n  party_name: extracted.customer || extracted.vendor || 'Unknown',\n  issue_date: extracted.issue_date || '',\n  total: total,\n  currency: extracted.currency || 'MYR',\n  \n  // Validation details\n  errors: validation.errors || [],\n  warnings: validation.warnings || [],\n  flags: validation.flags || [],\n  \n  // Review metadata\n  flagged_at: new Date().toISOString(),\n  review_status: 'pending',\n  reviewer: null,\n  reviewed_at: null\n};\n\n// ==================== CREATE REVIEW MESSAGE (always generate) ====================\n\nfunction makeReviewMessage(opts) {\n  const {\n    docNo, docType, party, amt, date, confPct,\n    issues = [], errors = [], warnings = [],\n    severity = 'INFO', mode = 'review' // 'review' | 'auto' | 'pass'\n  } = opts;\n\n  const lines = [];\n\n  if (mode === 'auto') {\n    lines.push(`✅ *Document Auto-Approved*`);\n  } else if (mode === 'pass') {\n    lines.push(`ℹ️ *Document Passed Checks*`);\n  } else {\n    lines.push(`🚨 *Document Requires Review*`);\n  }\n\n  lines.push('');\n  lines.push(`*Document:* ${docNo || '(no-number)'} (${docType || 'document'})`);\n  lines.push(`*Party:* ${party || 'Unknown'}`);\n  lines.push(`*Amount:* RM ${Number(amt || 0).toLocaleString('en-MY', {minimumFractionDigits:2, maximumFractionDigits:2})}`);\n  if (date) lines.push(`*Date:* ${date}`);\n  if (!Number.isNaN(confPct)) lines.push(`*Confidence:* ${Math.round(confPct)}%`);\n\n  if (mode === 'review' && issues.length) {\n    lines.push('');\n    lines.push(`*⚠️ Issues (${issues.length}):*`);\n    issues.forEach((s, i) => lines.push(`${i + 1}. ${s}`));\n  }\n\n  if (mode === 'review' && errors && errors.length) {\n    lines.push('');\n    lines.push(`*❌ Errors:*`);\n    errors.forEach((e, i) => lines.push(`${i + 1}. ${e}`));\n  }\n\n  if (mode === 'review' && warnings && warnings.length && warnings.length <= 3) {\n    lines.push('');\n    lines.push(`*⚠️ Warnings:*`);\n    warnings.forEach((w, i) => lines.push(`${i + 1}. ${w}`));\n  }\n\n  lines.push('');\n  lines.push(`*Severity:* ${severity.toUpperCase()}`);\n\n  if (mode === 'review') {\n    lines.push('');\n    lines.push(`*Action Required:*`);\n    lines.push(`Please review this document and respond:`);\n    lines.push(`✅ *APPROVE* - Process this document`);\n    lines.push(`❌ *REJECT* - Reject and flag`);\n    lines.push(`✏️ *CORRECT [field]=[value]* - Fix and retry`);\n  }\n\n  return lines.join('\\n');\n}\n\nlet reviewMessageMode = requiresReview ? 'review' : 'pass'; // default\nlet reviewMessage = ''; // final text generated below\n\n// ==================== AUTO-APPROVE CONDITIONS ====================\n\nconst autoApproveConditions = {\n  high_confidence: confidence >= HIGH_CONFIDENCE_THRESHOLD,\n  validation_passed: validation.is_valid === true,\n  no_warnings: !validation.warnings || validation.warnings.length === 0,\n  known_party: !validation.flags || !validation.flags.includes('UNKNOWN_PARTY'),\n  reasonable_amount: total < 50000,\n  posted_successfully: $json.posting_summary && $json.posting_summary.posted === true\n};\n\nconst canAutoApprove = !requiresReview && \n                       autoApproveConditions.high_confidence &&\n                       autoApproveConditions.validation_passed;\n\nif (canAutoApprove) {\n  reviewMessageMode = 'auto';\n  console.log(\"\\n🎯 AUTO-APPROVED:\");\n  console.log(\"  High confidence:\", autoApproveConditions.high_confidence ? \"✓\" : \"✗\");\n  console.log(\"  Validation passed:\", autoApproveConditions.validation_passed ? \"✓\" : \"✗\");\n  console.log(\"  No warnings:\", autoApproveConditions.no_warnings ? \"✓\" : \"✗\");\n  console.log(\"  Known party:\", autoApproveConditions.known_party ? \"✓\" : \"✗\");\n  exceptionReport.review_status = 'auto_approved';\n  exceptionReport.reviewed_at = new Date().toISOString();\n  exceptionReport.reviewer = 'system';\n}\n\n// Build the message text (ALWAYS)\nreviewMessage = makeReviewMessage({\n  docNo: docNumber,\n  docType,\n  party: exceptionReport.party_name,\n  amt: total,\n  date: extracted.issue_date || 'N/A',\n  confPct: (confidence || 0) * 100,\n  issues: exceptionReasons,\n  errors: validation.errors || [],\n  warnings: validation.warnings || [],\n  severity: overallSeverity || 'info',\n  mode: reviewMessageMode\n});\n\n// Console preview\nconsole.log(\"\\n\" + \"=\".repeat(80));\nconsole.log(reviewMessageMode === 'auto'\n  ? \"✅ DOCUMENT AUTO-APPROVED MESSAGE\"\n  : (reviewMessageMode === 'pass' ? \"ℹ️ DOCUMENT PASS MESSAGE\" : \"🚨 DOCUMENT REVIEW MESSAGE\"));\nconsole.log(\"=\".repeat(80));\nconsole.log(reviewMessage);\nconsole.log(\"=\".repeat(80));\n\n// ==================== EXCEPTION SUMMARY ====================\n\nconst exceptionSummary = {\n  requires_review: requiresReview,\n  can_auto_approve: canAutoApprove,\n  severity: overallSeverity,\n  exception_count: exceptionReasons.length,\n  review_status: exceptionReport.review_status,\n  \n  // Routing decision\n  route_to: requiresReview ? 'human_review' : (canAutoApprove ? 'auto_process' : 'continue_processing'),\n  next_action: requiresReview ? 'await_approval' : (canAutoApprove ? 'post_approved' : 'continue_processing'),\n  \n  // Statistics\n  confidence: confidence,\n  validation_passed: validation.is_valid,\n  posted: $json.posting_summary ? $json.posting_summary.posted : false,\n  \n  // Metadata\n  flagged_at: exceptionReport.flagged_at\n};\n\nconsole.log(\"\\n=== EXCEPTION SUMMARY ===\");\nconsole.log(\"Requires Review:\", requiresReview ? \"YES 🚨\" : \"NO ✓\");\nconsole.log(\"Can Auto-Approve:\", canAutoApprove ? \"YES ✓\" : \"NO\");\nconsole.log(\"Severity:\", overallSeverity.toUpperCase());\nconsole.log(\"Exception Count:\", exceptionReasons.length);\nconsole.log(\"Route To:\", exceptionSummary.route_to);\nconsole.log(\"Next Action:\", exceptionSummary.next_action);\n\n// ==================== PERSIST REVIEW MESSAGE IN ALL COMMON PLACES ====================\n\n// 1) place on exception_report\nexceptionReport.review_message = reviewMessage;\n\n// 2) place on row if available (helps WhatsApp/Slack sender and Sheets display)\nif (row) row.review_message = reviewMessage;\n\n// 3) embed inside snapshot_json if available\nif (snap && typeof snap === 'object') {\n  snap.review_message = reviewMessage;\n  snap.exception_report = snap.exception_report || {};\n  snap.exception_report.review_message = reviewMessage;\n}\n\n// ==================== RETURN ====================\n\nconst result = {\n  ...$json,\n  exception_report: exceptionReport,\n  exception_summary: exceptionSummary,\n  review_message: reviewMessage,\n  requires_review: requiresReview,\n  auto_approved: canAutoApprove\n};\n\n// write back updated row/snapshot_json (if we had them)\nif (row) result.row = row;\nif (snap) {\n  try { result.snapshot_json = JSON.stringify(snap); }\n  catch { /* ignore stringify errors */ }\n}\n\nreturn { json: result };\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        4912,
        608
      ],
      "id": "8a184fe1-cdbe-4aaf-be94-bd878be1b8ef",
      "name": "Exception Desk"
    },
    {
      "parameters": {
        "mode": "runOnceForEachItem",
        "jsCode": "// @ts-nocheck\nfunction safe(v, d = '') { return (v === 0 || !!v) ? v : d; }\n\nconst item = $json;                                   // this item only\nconst reviewId = `${Date.now()}-${Math.random().toString(36).slice(2,8)}`;\nconst channel = item.channel || 'whatsapp';\n\nconst requestorPhone = String(item.sender_phone || '').replace(/[^\\d]/g, '');\nconst DEFAULT_APPROVER_PHONE = '15551234567';\nconst approverPhone = String(DEFAULT_APPROVER_PHONE).replace(/[^\\d]/g, '');\nconst toPhone = approverPhone || requestorPhone;\n\nconst doc = {\n  review_id: reviewId,\n  doc_type: item.extracted?.doc_type || item.doc_type || 'unknown',\n  doc_number: item.extracted?.doc_number || item.doc_number || '',\n  issue_date: item.extracted?.issue_date || '',\n  vendor: item.extracted?.vendor || '',\n  customer: item.extracted?.customer || '',\n  currency: item.extracted?.currency || item.currency || '',\n  subtotal: safe(item.extracted?.subtotal, null),\n  tax: safe(item.extracted?.tax, null),\n  shipping: safe(item.extracted?.shipping, null),\n  total: safe(item.extracted?.total, null),\n  validation: item.validation || {},\n  extraction_confidence: item.extraction_confidence ?? item.extracted?.extraction_confidence ?? 0,\n  source_channel: channel,\n  original: item,\n};\n\nconst issues = [];\nif (doc.extraction_confidence < 0.75) issues.push(`Low confidence (${doc.extraction_confidence})`);\nif (doc.validation?.total_mismatch) issues.push('Total mismatch');\nif (!doc.vendor) issues.push('Missing vendor');\nif (!doc.customer) issues.push('Missing customer');\nif (Array.isArray(doc.validation?.errors) && doc.validation.errors.length)\n  issues.push(...doc.validation.errors.map(e => `Err: ${e}`));\nconst issueText = issues.length ? issues.join(' • ') : '—';\n\nconst body = [\n  `Review ID: ${doc.review_id}`,\n  `Type: ${doc.doc_type}`,\n  `Number: ${doc.doc_number || '—'}`,\n  `Date: ${doc.issue_date || '—'}`,\n  `Vendor: ${doc.vendor || '—'}`,\n  `Customer: ${doc.customer || '—'}`,\n  `Currency: ${doc.currency || '—'}`,\n  `Subtotal: ${doc.subtotal ?? '—'}`,\n  `Tax: ${doc.tax ?? '—'}`,\n  `Shipping: ${doc.shipping ?? '—'}`,\n  `Total: ${doc.total ?? '—'}`,\n  ``,\n  `Issues: ${issueText}`,\n  ``,\n  `How to reply:`,\n  ``,\n  `1) Approve the document:`,\n  `   APPROVE ${doc.review_id}`,\n  ``,\n  `2) Reject the document with a reason:`,\n  `   REJECT ${doc.review_id} wrong total`,\n  `   REJECT ${doc.review_id} vendor mismatch`,\n  ``,\n  `3) Correct fields directly (use field=value pairs):`,\n  `   CORRECT ${doc.review_id} total=2500; tax=0; currency=MYR`,\n  ``,\n  `Note: Separate corrections with semicolons. Case insensitive.`,\n].join('\\n');\n\n\nconst nowIso = new Date().toISOString();\n\nreturn {\n  json: {\n    ...item,\n    review: {\n      message: body,\n      review_id: doc.review_id,\n      to_phone: toPhone,\n      approver_phone: approverPhone,\n      requestor_phone: requestorPhone || undefined,\n      issues,\n      snapshot: doc,\n      status: 'pending',\n      channel,\n    },\n    exceptions_log: {\n      review_id: doc.review_id,\n      status: 'pending',\n      doc_type: doc.doc_type,\n      doc_number: doc.doc_number,\n      vendor: doc.vendor,\n      customer: doc.customer,\n      issues: issues.join('; '),\n      channel,\n      approver_phone: approverPhone,\n      requestor_phone: requestorPhone,\n      to_phone: toPhone,\n      snapshot_json: JSON.stringify(doc),\n      corrections_json: '',\n      reason: '',\n      created_at: nowIso,\n      updated_at: nowIso\n    }\n  }\n};\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        5360,
        320
      ],
      "id": "0e3d0113-88b5-47f8-9005-3434f6d80399",
      "name": "Review Payload"
    },
    {
      "parameters": {
        "operation": "append",
        "documentId": {
          "__rl": true,
          "value": "1S8guRrH8b-z0I7axmZfagJyx9aykK8hygcI2RDn1X7E",
          "mode": "list",
          "cachedResultName": "Exceptions_Log",
          "cachedResultUrl": "https://docs.google.com/spreadsheets/d/1S8guRrH8b-z0I7axmZfagJyx9aykK8hygcI2RDn1X7E/edit?usp=drivesdk"
        },
        "sheetName": {
          "__rl": true,
          "value": "gid=0",
          "mode": "list",
          "cachedResultName": "Sheet1",
          "cachedResultUrl": "https://docs.google.com/spreadsheets/d/1S8guRrH8b-z0I7axmZfagJyx9aykK8hygcI2RDn1X7E/edit#gid=0"
        },
        "columns": {
          "mappingMode": "defineBelow",
          "value": {
            "review_id": "={{$json.exceptions_log.review_id}}",
            "status": "={{$json.exceptions_log.status}}",
            "doc_type": "={{$json.exceptions_log.doc_type}}",
            "doc_number": "={{$json.exceptions_log.doc_number}}",
            "vendor ": "={{$json.exceptions_log.vendor}}",
            "customer": "={{$json.exceptions_log.customer}}",
            "issues": "={{$json.exceptions_log.issues}}",
            "channel": "={{$json.exceptions_log.channel}}",
            "approver_phone ": "={{$json.exceptions_log.approver_phone}}",
            "requestor_phone": "={{$json.exceptions_log.requestor_phone}}",
            "corrections_json": "={{$json.exceptions_log.corrections_json}}",
            "reason": "={{$json.exceptions_log.reason}}",
            "created_at": "={{$json.exceptions_log.created_at}}",
            "snapshot_json": "={{ $json.exceptions_log.snapshot_json }}"
          },
          "matchingColumns": [],
          "schema": [
            {
              "id": "review_id",
              "displayName": "review_id",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true
            },
            {
              "id": "status",
              "displayName": "status",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true
            },
            {
              "id": "doc_type",
              "displayName": "doc_type",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true
            },
            {
              "id": "doc_number",
              "displayName": "doc_number",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true
            },
            {
              "id": "vendor ",
              "displayName": "vendor ",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true
            },
            {
              "id": "customer",
              "displayName": "customer",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true
            },
            {
              "id": "issues",
              "displayName": "issues",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true
            },
            {
              "id": "channel",
              "displayName": "channel",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true
            },
            {
              "id": "approver_phone ",
              "displayName": "approver_phone ",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true
            },
            {
              "id": "requestor_phone",
              "displayName": "requestor_phone",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true
            },
            {
              "id": "snapshot_json",
              "displayName": "snapshot_json",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true,
              "removed": false
            },
            {
              "id": "corrections_json",
              "displayName": "corrections_json",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true
            },
            {
              "id": "reason",
              "displayName": "reason",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true
            },
            {
              "id": "created_at",
              "displayName": "created_at",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true
            }
          ],
          "attemptToConvertTypes": false,
          "convertFieldsToString": false
        },
        "options": {}
      },
      "type": "n8n-nodes-base.googleSheets",
      "typeVersion": 4.7,
      "position": [
        5584,
        320
      ],
      "id": "14909c68-6561-4877-ae4c-2e5e4250522f",
      "name": "Append row in sheet",
      "credentials": {
        "googleSheetsOAuth2Api": {
          "id": "UyGfxGtg3Jm7hDky",
          "name": "Google Sheets account"
        }
      }
    },
    {
      "parameters": {
        "operation": "send",
        "phoneNumberId": "894424953747457",
        "recipientPhoneNumber": "=601123368808",
        "textBody": "={{ $('Review Payload').item.json.review.snapshot.original.exception_report.review_message }}\n\nReview ID: {{ $json.review_id }}\n\nHow to reply:\n\n1) Approve:\n   APPROVE {{ $json.review_id }}\n\n2) Reject:\n   REJECT {{ $json.review_id }} wrong total\n\n3) Correct:\n   CORRECT {{ $json.review_id }} total=450; vendor=ABC Sdn Bhd\n",
        "additionalFields": {}
      },
      "type": "n8n-nodes-base.whatsApp",
      "typeVersion": 1.1,
      "position": [
        5824,
        320
      ],
      "id": "a9f520fa-25f8-4bec-bd1c-1123a055d4af",
      "name": "Send Approval Request",
      "webhookId": "80dcda30-06d2-4955-afcc-d26476be1d3b",
      "credentials": {
        "whatsAppApi": {
          "id": "JMiSrW34DEwGkuPT",
          "name": "WhatsApp account"
        }
      }
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict",
            "version": 2
          },
          "conditions": [
            {
              "id": "a21e04db-504e-40f1-b910-e23f03f99592",
              "leftValue": "={{ $json.exception_summary.confidence }}",
              "rightValue": 0.75,
              "operator": {
                "type": "number",
                "operation": "lt"
              }
            },
            {
              "id": "ac6b5503-6280-43c5-a0bd-cdb12821db61",
              "leftValue": "={{ $json.exception_summary.requires_review }}",
              "rightValue": "true",
              "operator": {
                "type": "boolean",
                "operation": "true",
                "singleValue": true
              }
            }
          ],
          "combinator": "or"
        },
        "options": {}
      },
      "type": "n8n-nodes-base.if",
      "typeVersion": 2.2,
      "position": [
        5136,
        608
      ],
      "id": "09a8b599-a669-4fd3-be3b-7faa99bb4fdc",
      "name": "Flags Problem"
    },
    {
      "parameters": {
        "jsCode": "// @ts-nocheck\nfunction safe(n){ return Number.isFinite(+n) ? +n : 0; }\nfunction uid(){ return `${Date.now()}-${Math.random().toString(36).slice(2,8)}`; }\n\nconst todayISO = new Date().toISOString().slice(0,10);\n\n// ---- date helpers ----\nconst toDate = (s) => {\n  if (!s) return null;\n  const d = new Date(s);\n  return isNaN(d.getTime()) ? null : d;\n};\nconst daysBetween = (a,b) => {\n  if (!a || !b) return 0;\n  const ms = a.getTime() - b.getTime();\n  return Math.floor(ms / (1000*60*60*24));\n};\n\n// days past due (clamped >= 0). If due_date missing, use days since issue_date.\nfunction computeDaysOutstanding(issueISO, dueISO) {\n  const today = toDate(todayISO);\n  const issue = toDate(issueISO);\n  const due = toDate(dueISO);\n  if (due) return Math.max(0, daysBetween(today, due));\n  if (issue) return Math.max(0, daysBetween(today, issue)); // fallback\n  return 0;\n}\n\n// standard 0-30 / 31-60 / 61-90 / 90+\nfunction agingBucket(days) {\n  if (days <= 30) return '0-30';\n  if (days <= 60) return '31-60';\n  if (days <= 90) return '61-90';\n  return '90+';\n}\n\n// derive direction and party for aging\nfunction deriveDirectionAndParty(ex, norm) {\n  const docType = (ex.doc_type || '').toLowerCase();\n  const hasCustomer = !!(ex.customer || norm.party_type === 'customer');\n  const hasVendor   = !!(ex.vendor   || norm.party_type === 'vendor');\n\n  // Your workflow uses 'invoice' for AR and 'supplier_invoice' (or bill) for AP\n  if (docType === 'invoice' || hasCustomer) {\n    return {\n      direction: 'AR',\n      party_id: ex.party_id || norm.party_id || '',\n      party_name: ex.party_name || ex.customer || ''\n    };\n  }\n  if (docType === 'supplier_invoice' || docType === 'bill' || hasVendor) {\n    return {\n      direction: 'AP',\n      party_id: ex.party_id || norm.party_id || '',\n      party_name: ex.party_name || ex.vendor || ''\n    };\n  }\n  // default to AR for unknown invoices; you can tighten as needed\n  return {\n    direction: 'AR',\n    party_id: ex.party_id || norm.party_id || '',\n    party_name: ex.party_name || ex.customer || ex.vendor || ''\n  };\n}\n\n// sum allocated amounts for this document if available\nfunction getAmountPaid(x, ex) {\n  const rec = x.reconciliation || {};\n  const allocations = Array.isArray(rec.payment_allocations) ? rec.payment_allocations : [];\n  // Try to match by invoice_number first, then by doc_number fallback\n  const key = ex.doc_number || x.doc_number || '';\n  const paid = allocations\n    .filter(a =>\n      (a.invoice_number && a.invoice_number === key) ||\n      (a.doc_number && a.doc_number === key)\n    )\n    .reduce((sum, a) => sum + safe(a.allocated_amount ?? a.payment_amount), 0);\n  return paid;\n}\n\nconst inputs = $input.all();\nconst out = [];\n\nfor (const it of inputs) {\n  const x = it.json;\n  const ex = x.extracted || x.extracted_enriched || {};\n  const norm = x.normalized || {};\n  const docType = (ex.doc_type || x.doc_type || '').toLowerCase();\n  const isInvoice = docType === 'invoice';\n  const isSupplierInvoice = docType === 'supplier_invoice' || docType === 'bill';\n  const baseCcy = norm.base_currency || ex.currency || x.currency || 'MYR';\n\n  // Documents.csv row\n  const docRow = {\n    id: x.hash_key || `${(ex.doc_type||x.doc_type||'doc')}:${ex.doc_number||x.doc_number||uid()}`,\n    doc_type: ex.doc_type || x.doc_type || 'unknown',\n    doc_number: ex.doc_number || x.doc_number || '',\n    vendor_customer_id: ex.party_id || norm.party_id || '',\n    issue_date: ex.issue_date || '',\n    due_date: ex.due_date || '',\n    currency: ex.currency || baseCcy,\n    subtotal: safe(ex.subtotal ?? norm.subtotal),\n    tax_rate: safe(ex.tax_rate ?? norm.tax_rate),\n    total: safe(ex.total ?? norm.total),\n  };\n\n  // JournalEntries.csv rows (unchanged from yours)\n  const je = [];\n  const total = safe(ex.total ?? norm.total);\n  const subtotal = safe(ex.subtotal ?? norm.subtotal);\n  const tax = safe(ex.tax ?? norm.tax);\n  const date = ex.issue_date || new Date().toISOString().slice(0,10);\n  const docId = docRow.id;\n  const fxr = norm.fx_rate || 1;\n\n  if (isInvoice) {\n    je.push(\n      { je_id: uid(), date, doc_id: docId, account: 'Accounts Receivable', debit: total,    credit: 0,        memo: 'AR from invoice', fx_rate: fxr, base_amount: total },\n      { je_id: uid(), date, doc_id: docId, account: 'Sales Revenue',       debit: 0,        credit: subtotal, memo: 'Sales',           fx_rate: fxr, base_amount: subtotal },\n    );\n    if (tax) je.push({ je_id: uid(), date, doc_id: docId, account: 'Tax Payable (SST)', debit: 0, credit: tax, memo: ex.tax_type || 'SST', fx_rate: fxr, base_amount: tax });\n  } else if (isSupplierInvoice) {\n    je.push(\n      { je_id: uid(), date, doc_id: docId, account: 'Expense - General', debit: subtotal, credit: 0, memo: 'Vendor bill', fx_rate: fxr, base_amount: subtotal },\n      { je_id: uid(), date, doc_id: docId, account: 'Accounts Payable',  debit: 0,        credit: total, memo: 'AP',       fx_rate: fxr, base_amount: total },\n    );\n    if (tax) je.push({ je_id: uid(), date, doc_id: docId, account: 'Tax Recoverable (SST)', debit: tax, credit: 0, memo: ex.tax_type || 'SST', fx_rate: fxr, base_amount: tax });\n  }\n\n  // Vendors/Customers.csv row\n  const party = {\n    id: ex.party_id || norm.party_id || '',\n    name: ex.party_name || (isInvoice ? ex.customer : ex.vendor) || '',\n    reg_no: ex.party_tax_id || '',\n    phone: '', email: '', address: '',\n    currency: ex.party_currency || ex.currency || baseCcy,\n    status: 'active'\n  };\n\n  // SST.csv row\n  const sstRow = tax ? {\n    date, doc_id: docId,\n    party_name: party.name || '',\n    tax_type: ex.tax_type || 'SST',\n    tax_rate: safe(ex.tax_rate ?? norm.tax_rate),\n    tax_amount: tax,\n    base_amount: subtotal,\n    direction: isInvoice ? 'Output' : 'Input'\n  } : null;\n\n  // ---------- NEW: AgingSnapshots.csv row ----------\n  // only for invoices/bills with a positive total\n  if ((isInvoice || isSupplierInvoice) && total > 0) {\n    const { direction, party_id, party_name } = deriveDirectionAndParty(ex, norm);\n    const amountPaid = safe(getAmountPaid(x, ex));\n    const balance = Math.max(0, +(total - amountPaid).toFixed(2));\n\n    const days = computeDaysOutstanding(docRow.issue_date, docRow.due_date);\n    const bucket = agingBucket(days);\n\n    // status rules\n    let status = 'open';\n    if (balance <= 0.009) status = 'paid';\n    else if (amountPaid > 0) status = 'partially_paid';\n    else if (days > 0) status = 'overdue';\n\n    const agingRow = {\n      snapshot_date: todayISO,\n      direction,                                   // 'AR' or 'AP'\n      doc_type: docRow.doc_type,\n      doc_number: docRow.doc_number,\n      party_id: party_id,\n      party_name: party_name,\n      issue_date: docRow.issue_date || '',\n      due_date: docRow.due_date || '',\n      currency: docRow.currency,\n      original_total: total,\n      amount_paid: amountPaid,\n      balance_open: balance,\n      days_outstanding: days,\n      aging_bucket: bucket,\n      status\n    };\n\n    out.push({ json: { kind: 'aging', row: agingRow } });\n  }\n\n  // Emit existing kinds\n  out.push({ json: { kind: 'document', row: docRow } });\n  je.forEach(r => out.push({ json: { kind: 'je', row: r } }));\n  if (party.id && party.name) out.push({ json: { kind: isInvoice ? 'customer' : 'vendor', row: party } });\n  if (sstRow) out.push({ json: { kind: 'sst', row: sstRow } });\n}\n\n// final safety: ensure every element is {json: object}\nreturn out.map(it => ({ json: { ...it.json } }));\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        5360,
        896
      ],
      "id": "09cc07be-4da4-4491-baea-bcbefd6a0239",
      "name": "Build Export Row"
    },
    {
      "parameters": {
        "rules": {
          "values": [
            {
              "conditions": {
                "options": {
                  "caseSensitive": true,
                  "leftValue": "",
                  "typeValidation": "strict",
                  "version": 2
                },
                "conditions": [
                  {
                    "leftValue": "={{$json.kind}}",
                    "rightValue": "document",
                    "operator": {
                      "type": "string",
                      "operation": "equals"
                    },
                    "id": "c65a3b10-36c5-4e0f-a86d-1aec1093ff9b"
                  }
                ],
                "combinator": "and"
              },
              "renameOutput": true,
              "outputKey": "Documents"
            },
            {
              "conditions": {
                "options": {
                  "caseSensitive": true,
                  "leftValue": "",
                  "typeValidation": "strict",
                  "version": 2
                },
                "conditions": [
                  {
                    "id": "a91a1bf1-54c2-4e90-be8b-42ec1ddb659e",
                    "leftValue": "={{$json.kind}}",
                    "rightValue": "je",
                    "operator": {
                      "type": "string",
                      "operation": "equals",
                      "name": "filter.operator.equals"
                    }
                  }
                ],
                "combinator": "and"
              },
              "renameOutput": true,
              "outputKey": "JournalEntries"
            },
            {
              "conditions": {
                "options": {
                  "caseSensitive": true,
                  "leftValue": "",
                  "typeValidation": "strict",
                  "version": 2
                },
                "conditions": [
                  {
                    "id": "074a6b80-5352-4f2c-9cc7-e8d2421a0dc6",
                    "leftValue": "={{$json.kind}}",
                    "rightValue": "customer",
                    "operator": {
                      "type": "string",
                      "operation": "equals",
                      "name": "filter.operator.equals"
                    }
                  }
                ],
                "combinator": "and"
              },
              "renameOutput": true,
              "outputKey": "Customers"
            },
            {
              "conditions": {
                "options": {
                  "caseSensitive": true,
                  "leftValue": "",
                  "typeValidation": "strict",
                  "version": 2
                },
                "conditions": [
                  {
                    "id": "7bbbb3d1-d81a-4c09-8387-4cf82d0a85fe",
                    "leftValue": "={{$json.kind}}",
                    "rightValue": "vendor",
                    "operator": {
                      "type": "string",
                      "operation": "equals",
                      "name": "filter.operator.equals"
                    }
                  }
                ],
                "combinator": "and"
              },
              "renameOutput": true,
              "outputKey": "Vendors"
            },
            {
              "conditions": {
                "options": {
                  "caseSensitive": true,
                  "leftValue": "",
                  "typeValidation": "strict",
                  "version": 2
                },
                "conditions": [
                  {
                    "id": "22d4d50c-59c6-4eea-ad0d-448f96cd51bc",
                    "leftValue": "={{$json.kind}}",
                    "rightValue": "sst",
                    "operator": {
                      "type": "string",
                      "operation": "equals",
                      "name": "filter.operator.equals"
                    }
                  }
                ],
                "combinator": "and"
              },
              "renameOutput": true,
              "outputKey": "SST_Tax"
            },
            {
              "conditions": {
                "options": {
                  "caseSensitive": true,
                  "leftValue": "",
                  "typeValidation": "strict",
                  "version": 2
                },
                "conditions": [
                  {
                    "id": "b2e7a619-fc79-4332-98ad-cba775f73a46",
                    "leftValue": "={{$json.kind}}",
                    "rightValue": "aging",
                    "operator": {
                      "type": "string",
                      "operation": "equals",
                      "name": "filter.operator.equals"
                    }
                  }
                ],
                "combinator": "and"
              },
              "renameOutput": true,
              "outputKey": "Aging"
            }
          ]
        },
        "options": {}
      },
      "type": "n8n-nodes-base.switch",
      "typeVersion": 3.3,
      "position": [
        5584,
        848
      ],
      "id": "c4a66eec-2459-41ad-aee8-7f34fb46292c",
      "name": "Sheets Switch"
    },
    {
      "parameters": {
        "operation": "append",
        "documentId": {
          "__rl": true,
          "value": "1pwDfyamEmMxFgndj1gUoWlKgBgl3jqk823Nya8swCgc",
          "mode": "list",
          "cachedResultName": "Documents",
          "cachedResultUrl": "https://docs.google.com/spreadsheets/d/1pwDfyamEmMxFgndj1gUoWlKgBgl3jqk823Nya8swCgc/edit?usp=drivesdk"
        },
        "sheetName": {
          "__rl": true,
          "value": "gid=0",
          "mode": "list",
          "cachedResultName": "Sheet1",
          "cachedResultUrl": "https://docs.google.com/spreadsheets/d/1pwDfyamEmMxFgndj1gUoWlKgBgl3jqk823Nya8swCgc/edit#gid=0"
        },
        "columns": {
          "mappingMode": "defineBelow",
          "value": {
            "id": "={{$json.row.id}}",
            "doc_type": "={{$json.row.doc_type}}",
            "doc_number": "={{$json.row.doc_number}}",
            "vendor_customer_id": "={{$json.row.vendor_customer_id}}",
            "issue_date": "={{$json.row.issue_date}}",
            "due_date": "={{$json.row.due_date}}",
            "currency": "={{$json.row.currency}}",
            "subtotal": "={{$json.row.subtotal}}",
            "tax_rate": "={{$json.row.tax_rate}}",
            "total": "={{$json.row.total}}"
          },
          "matchingColumns": [
            "id"
          ],
          "schema": [
            {
              "id": "id",
              "displayName": "id",
              "required": false,
              "defaultMatch": true,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true,
              "removed": false
            },
            {
              "id": "doc_type",
              "displayName": "doc_type",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true
            },
            {
              "id": "doc_number",
              "displayName": "doc_number",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true
            },
            {
              "id": "vendor_customer_id",
              "displayName": "vendor_customer_id",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true
            },
            {
              "id": "issue_date",
              "displayName": "issue_date",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true
            },
            {
              "id": "due_date",
              "displayName": "due_date",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true
            },
            {
              "id": "currency",
              "displayName": "currency",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true
            },
            {
              "id": "subtotal",
              "displayName": "subtotal",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true
            },
            {
              "id": "tax_rate",
              "displayName": "tax_rate",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true
            },
            {
              "id": "total",
              "displayName": "total",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true
            }
          ],
          "attemptToConvertTypes": false,
          "convertFieldsToString": false
        },
        "options": {}
      },
      "type": "n8n-nodes-base.googleSheets",
      "typeVersion": 4.7,
      "position": [
        5808,
        512
      ],
      "id": "4b54d21a-ae48-4ed5-b58e-49c93b7a4d81",
      "name": "Append Documents",
      "credentials": {
        "googleSheetsOAuth2Api": {
          "id": "UyGfxGtg3Jm7hDky",
          "name": "Google Sheets account"
        }
      }
    },
    {
      "parameters": {
        "operation": "append",
        "documentId": {
          "__rl": true,
          "value": "1qW2sBvBW1kmY7yorSSez67-rPt4B0xyYTCVD2wYXZJU",
          "mode": "list",
          "cachedResultName": "JournalEntries",
          "cachedResultUrl": "https://docs.google.com/spreadsheets/d/1qW2sBvBW1kmY7yorSSez67-rPt4B0xyYTCVD2wYXZJU/edit?usp=drivesdk"
        },
        "sheetName": {
          "__rl": true,
          "value": "gid=0",
          "mode": "list",
          "cachedResultName": "Sheet1",
          "cachedResultUrl": "https://docs.google.com/spreadsheets/d/1qW2sBvBW1kmY7yorSSez67-rPt4B0xyYTCVD2wYXZJU/edit#gid=0"
        },
        "columns": {
          "mappingMode": "defineBelow",
          "value": {
            "je_id": "={{$json.row.je_id}}",
            "date": "={{$json.row.date}}",
            "doc_id": "={{$json.row.doc_id}}",
            "account": "={{$json.row.account}}",
            "debit": "={{$json.row.debit}}",
            "credit": "={{$json.row.credit}}",
            "memo": "={{$json.row.memo}}",
            "fx_rate": "={{$json.row.fx_rate}}",
            "base_amount": "={{$json.row.base_amount}}"
          },
          "matchingColumns": [],
          "schema": [
            {
              "id": "je_id",
              "displayName": "je_id",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true
            },
            {
              "id": "date",
              "displayName": "date",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true
            },
            {
              "id": "doc_id",
              "displayName": "doc_id",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true
            },
            {
              "id": "account",
              "displayName": "account",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true
            },
            {
              "id": "debit",
              "displayName": "debit",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true
            },
            {
              "id": "credit",
              "displayName": "credit",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true,
              "removed": false
            },
            {
              "id": "memo",
              "displayName": "memo",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true
            },
            {
              "id": "fx_rate",
              "displayName": "fx_rate",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true
            },
            {
              "id": "base_amount",
              "displayName": "base_amount",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true
            }
          ],
          "attemptToConvertTypes": false,
          "convertFieldsToString": false
        },
        "options": {}
      },
      "type": "n8n-nodes-base.googleSheets",
      "typeVersion": 4.7,
      "position": [
        5808,
        704
      ],
      "id": "faddf5ca-b9bb-4ae2-87a5-630c458b988a",
      "name": "Append JournalEntries",
      "credentials": {
        "googleSheetsOAuth2Api": {
          "id": "UyGfxGtg3Jm7hDky",
          "name": "Google Sheets account"
        }
      }
    },
    {
      "parameters": {
        "operation": "append",
        "documentId": {
          "__rl": true,
          "value": "19tXsUA6KKK8nYLpgaWc1HxkfqHdF1_Umt6lMAC0XSiM",
          "mode": "list",
          "cachedResultName": "Customers",
          "cachedResultUrl": "https://docs.google.com/spreadsheets/d/19tXsUA6KKK8nYLpgaWc1HxkfqHdF1_Umt6lMAC0XSiM/edit?usp=drivesdk"
        },
        "sheetName": {
          "__rl": true,
          "value": "gid=0",
          "mode": "list",
          "cachedResultName": "Sheet1",
          "cachedResultUrl": "https://docs.google.com/spreadsheets/d/19tXsUA6KKK8nYLpgaWc1HxkfqHdF1_Umt6lMAC0XSiM/edit#gid=0"
        },
        "columns": {
          "mappingMode": "defineBelow",
          "value": {
            "id": "={{ $json.row.id }}",
            "name": "={{ $json.row.name }}",
            "reg_no": "={{ $json.row.reg_no }}",
            "phone": "={{ $json.row.phone }}",
            "email": "={{ $json.row.email }}",
            "address": "={{ $json.row.address }}",
            "currency": "={{ $json.row.currency }}",
            "status": "={{ $json.row.status }}"
          },
          "matchingColumns": [
            "id"
          ],
          "schema": [
            {
              "id": "id",
              "displayName": "id",
              "required": false,
              "defaultMatch": true,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true,
              "removed": false
            },
            {
              "id": "name",
              "displayName": "name",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true
            },
            {
              "id": "reg_no",
              "displayName": "reg_no",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true
            },
            {
              "id": "phone",
              "displayName": "phone",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true
            },
            {
              "id": "email",
              "displayName": "email",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true
            },
            {
              "id": "address",
              "displayName": "address",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true
            },
            {
              "id": "currency",
              "displayName": "currency",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true
            },
            {
              "id": "status",
              "displayName": "status",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true
            }
          ],
          "attemptToConvertTypes": false,
          "convertFieldsToString": false
        },
        "options": {}
      },
      "type": "n8n-nodes-base.googleSheets",
      "typeVersion": 4.7,
      "position": [
        5808,
        1088
      ],
      "id": "7fb5686d-6dca-408a-89aa-32be013d9926",
      "name": "Append Customers",
      "credentials": {
        "googleSheetsOAuth2Api": {
          "id": "UyGfxGtg3Jm7hDky",
          "name": "Google Sheets account"
        }
      }
    },
    {
      "parameters": {
        "operation": "append",
        "documentId": {
          "__rl": true,
          "value": "1fZrhxwlsobpEzbxuRkm_TnP_nSc4xLoqZprFt0UIY64",
          "mode": "list",
          "cachedResultName": "Vendors",
          "cachedResultUrl": "https://docs.google.com/spreadsheets/d/1fZrhxwlsobpEzbxuRkm_TnP_nSc4xLoqZprFt0UIY64/edit?usp=drivesdk"
        },
        "sheetName": {
          "__rl": true,
          "value": "gid=0",
          "mode": "list",
          "cachedResultName": "Sheet1",
          "cachedResultUrl": "https://docs.google.com/spreadsheets/d/1fZrhxwlsobpEzbxuRkm_TnP_nSc4xLoqZprFt0UIY64/edit#gid=0"
        },
        "columns": {
          "mappingMode": "defineBelow",
          "value": {},
          "matchingColumns": [
            "id"
          ],
          "schema": [
            {
              "id": "id",
              "displayName": "id",
              "required": false,
              "defaultMatch": true,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true,
              "removed": false
            },
            {
              "id": "name",
              "displayName": "name",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true
            },
            {
              "id": "reg_no",
              "displayName": "reg_no",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true
            },
            {
              "id": "phone",
              "displayName": "phone",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true
            },
            {
              "id": "email",
              "displayName": "email",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true
            },
            {
              "id": "address",
              "displayName": "address",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true
            },
            {
              "id": "currency",
              "displayName": "currency",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true
            },
            {
              "id": "status",
              "displayName": "status",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true
            }
          ],
          "attemptToConvertTypes": false,
          "convertFieldsToString": false
        },
        "options": {}
      },
      "type": "n8n-nodes-base.googleSheets",
      "typeVersion": 4.7,
      "position": [
        5808,
        896
      ],
      "id": "53cc1c1a-2641-404b-9073-6887d084854a",
      "name": "Append Vendors",
      "credentials": {
        "googleSheetsOAuth2Api": {
          "id": "UyGfxGtg3Jm7hDky",
          "name": "Google Sheets account"
        }
      }
    },
    {
      "parameters": {
        "operation": "append",
        "documentId": {
          "__rl": true,
          "value": "1yoSUGmYQs3LrnNjDlPatRXj3aryd91Z0NUAbbcT5qSs",
          "mode": "list",
          "cachedResultName": "SST_Tax",
          "cachedResultUrl": "https://docs.google.com/spreadsheets/d/1yoSUGmYQs3LrnNjDlPatRXj3aryd91Z0NUAbbcT5qSs/edit?usp=drivesdk"
        },
        "sheetName": {
          "__rl": true,
          "value": "gid=0",
          "mode": "list",
          "cachedResultName": "Sheet1",
          "cachedResultUrl": "https://docs.google.com/spreadsheets/d/1yoSUGmYQs3LrnNjDlPatRXj3aryd91Z0NUAbbcT5qSs/edit#gid=0"
        },
        "columns": {
          "mappingMode": "defineBelow",
          "value": {
            "date": "={{ $json.row.date }}",
            "doc_id": "={{ $json.row.doc_id }}",
            "party_name": "={{ $json.row.party_name }}",
            "tax_type": "={{ $json.row.tax_rate }}",
            "tax_rate": "={{ $json.row.tax_rate }}",
            "tax_amount": "={{ $json.row.tax_amount }}",
            "base_amount": "={{ $json.row.base_amount }}",
            "direction": "={{ $json.row.direction }}"
          },
          "matchingColumns": [],
          "schema": [
            {
              "id": "date",
              "displayName": "date",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true
            },
            {
              "id": "doc_id",
              "displayName": "doc_id",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true
            },
            {
              "id": "party_name",
              "displayName": "party_name",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true
            },
            {
              "id": "tax_type",
              "displayName": "tax_type",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true
            },
            {
              "id": "tax_rate",
              "displayName": "tax_rate",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true
            },
            {
              "id": "tax_amount",
              "displayName": "tax_amount",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true
            },
            {
              "id": "base_amount",
              "displayName": "base_amount",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true
            },
            {
              "id": "direction",
              "displayName": "direction",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true
            }
          ],
          "attemptToConvertTypes": false,
          "convertFieldsToString": false
        },
        "options": {}
      },
      "type": "n8n-nodes-base.googleSheets",
      "typeVersion": 4.7,
      "position": [
        5808,
        1280
      ],
      "id": "349412eb-024b-4d90-a6c6-fb363494e15d",
      "name": "Append SST",
      "credentials": {
        "googleSheetsOAuth2Api": {
          "id": "UyGfxGtg3Jm7hDky",
          "name": "Google Sheets account"
        }
      }
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict",
            "version": 2
          },
          "conditions": [
            {
              "id": "2916bea3-8031-4a8f-a3da-7c1282b2db38",
              "leftValue": "={{ $json.mime_type }}",
              "rightValue": "pdf",
              "operator": {
                "type": "string",
                "operation": "contains"
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "type": "n8n-nodes-base.if",
      "typeVersion": 2.2,
      "position": [
        496,
        704
      ],
      "id": "a080353a-b089-4b11-af33-1247c97246fa",
      "name": "If File/Image?"
    },
    {
      "parameters": {
        "modelName": "models/gemini-2.5-pro",
        "options": {}
      },
      "id": "088dd23d-6c6d-40d3-84ee-1cdab933c3d3",
      "name": "Google Gemini Chat Model",
      "type": "@n8n/n8n-nodes-langchain.lmChatGoogleGemini",
      "position": [
        1024,
        1232
      ],
      "typeVersion": 1,
      "credentials": {
        "googlePalmApi": {
          "id": "cw7rF9ZuxD2m1H8u",
          "name": "Google Gemini(PaLM) Api account"
        }
      }
    },
    {
      "parameters": {
        "promptType": "define",
        "text": "=TASK: Perform OCR and return plain text for downstream parsing.\n\nMULTI_PAGE: {{true|false}}   # true if you pass multiple images/pages\n\nRESPONSE_SCHEMA (strict):\n{\n  \"text\": \"string\",                     // full concatenated text\n  \"pages\": [                            // one item per page (if MULTI_PAGE=true)\n    {\n      \"page\": 1,\n      \"text\": \"string\"\n    }\n  ],\n  \"warnings\": [\"string\"],               // any OCR issues (noise/rotation/low contrast)\n  \"confidence_overall\": 0.0             // 0-1 rough confidence (your estimate)\n}\n\nReturn ONLY valid JSON, no markdown code fences.\n",
        "hasOutputParser": true,
        "messages": {
          "messageValues": [
            {
              "message": "=You are an OCR engine. Read the attached image(s)/page(s) and return only what is visibly present.\nDo NOT translate or infer missing values. Do NOT add fields that are not visible.\nKeep original casing, numbers, spacing where possible. Preserve line breaks.\nIf text is unclear, include it but wrap unreadable parts with [UNCERTAIN: …].\nReturn JSON only and follow the schema exactly.\n"
            },
            {
              "type": "HumanMessagePromptTemplate",
              "messageType": "imageBinary",
              "binaryImageDataKey": "file"
            }
          ]
        }
      },
      "id": "dcd09c49-98e5-4b5a-9fd2-c1f7e84ae639",
      "name": "Vertex A.I. extract text",
      "type": "@n8n/n8n-nodes-langchain.chainLlm",
      "position": [
        944,
        1008
      ],
      "typeVersion": 1.4
    },
    {
      "parameters": {
        "jsCode": "// Fan-out email attachments AND bubble up command replies (APPROVE/REJECT/CORRECT)\n// Works with IMAP/Gmail nodes that expose attachment_* binaries.\n\nfunction htmlToText(html = '') {\n  // very light HTML -> text fallback\n  return String(html)\n    .replace(/<br\\s*\\/?>/gi, '\\n')\n    .replace(/<\\/p>/gi, '\\n')\n    .replace(/<style[\\s\\S]*?<\\/style>/gi, '')\n    .replace(/<script[\\s\\S]*?<\\/script>/gi, '')\n    .replace(/<\\/?[^>]+>/g, '')\n    .replace(/&nbsp;/g, ' ')\n    .replace(/&amp;/g, '&')\n    .replace(/&lt;/g, '<')\n    .replace(/&gt;/g, '>')\n    .trim();\n}\n\nfunction pickBody(meta) {\n  // prefer plain text; fall back to stripped HTML; then empty string\n  const t = (meta.text ?? '').trim();\n  if (t) return t;\n  const h = (meta.html ?? '').trim();\n  if (h) return htmlToText(h);\n  return '';\n}\n\nfunction looksLikeCommand(s) {\n  // command must start the message or subject\n  // e.g. \"APPROVE\", \"REJECT reason...\", \"CORRECT 123 field=value\"\n  const m = String(s).trim().match(/^([A-Za-z]+)\\b/);\n  if (!m) return false;\n  const kw = m[1].toUpperCase();\n  return kw === 'APPROVE' || kw === 'REJECT' || kw === 'CORRECT';\n}\n\nconst out = [];\n\nfor (const item of $input.all()) {\n  const bins = item.binary ?? {};\n  const meta = item.json ?? {};\n\n  const from = String(meta.from ?? '');\n  const subject = String(meta.subject ?? '');\n  const received_at = meta.date ?? new Date().toISOString();\n\n  // 1) Emit one item per attachment, normalized to binary.file (unchanged behavior)\n  for (const key of Object.keys(bins)) {\n    if (key.startsWith('attachment')) {\n      out.push({\n        json: {\n          channel: 'email',\n          subject,\n          from,\n          received_at\n        },\n        binary: { file: bins[key] }\n      });\n    }\n  }\n\n  // 2) If the email is a command reply (no need for attachment), emit a command item\n  //    This lets your existing Parse Command node handle it (wa_text / wa_from pattern).\n  const body = pickBody(meta);\n  const bodyIsCmd = looksLikeCommand(body);\n  const subjectIsCmd = looksLikeCommand(subject);\n\n  if (bodyIsCmd || subjectIsCmd) {\n    // Prefer body as the authoritative command string; otherwise use subject.\n    const wa_text = bodyIsCmd ? body.trim() : subject.trim();\n\n    out.push({\n      json: {\n        channel: 'email',\n        // Keep these aligned with your WhatsApp command parser expectations:\n        wa_text,           // what your parser reads as the command string\n        wa_from: from,     // your parser strips non-digits; fine for email (will become \"\")\n        email_from: from,  // keep original for downstream if needed\n        subject,\n        received_at\n      }\n      // note: no binary on purpose for command-only messages\n    });\n  }\n}\n\n// If nothing matched (no attachments and no command), still pass nothing forward.\n// Downstream won’t run on empty arrays, which is fine.\nreturn out;\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -624,
        352
      ],
      "id": "6109eebd-6d82-433d-b4bb-7159905c810f",
      "name": "Parse Email Attachment"
    },
    {
      "parameters": {
        "mailbox": "Accounting Intake",
        "downloadAttachments": true,
        "options": {}
      },
      "type": "n8n-nodes-base.emailReadImap",
      "typeVersion": 2.1,
      "position": [
        -848,
        352
      ],
      "id": "ae03b0c3-9dec-43d1-98e1-59e577cee1e9",
      "name": "Email Trigger (IMAP)",
      "credentials": {
        "imap": {
          "id": "33jECazKbXbE3t4A",
          "name": "IMAP account 2"
        }
      }
    },
    {
      "parameters": {
        "rules": {
          "values": [
            {
              "conditions": {
                "options": {
                  "caseSensitive": true,
                  "leftValue": "",
                  "typeValidation": "strict",
                  "version": 2
                },
                "conditions": [
                  {
                    "leftValue": "={{ $json.is_command }}",
                    "rightValue": "",
                    "operator": {
                      "type": "boolean",
                      "operation": "true",
                      "singleValue": true
                    },
                    "id": "4659d776-72c3-4578-be1e-0b94605f3f17"
                  }
                ],
                "combinator": "and"
              },
              "renameOutput": true,
              "outputKey": "Command"
            },
            {
              "conditions": {
                "options": {
                  "caseSensitive": true,
                  "leftValue": "",
                  "typeValidation": "strict",
                  "version": 2
                },
                "conditions": [
                  {
                    "id": "bb591953-4900-4ef7-9b06-a1d011235fd4",
                    "leftValue": "={{ $json.channel }}",
                    "rightValue": "whatsapp",
                    "operator": {
                      "type": "string",
                      "operation": "equals",
                      "name": "filter.operator.equals"
                    }
                  }
                ],
                "combinator": "and"
              },
              "renameOutput": true,
              "outputKey": "Whatsapp"
            },
            {
              "conditions": {
                "options": {
                  "caseSensitive": true,
                  "leftValue": "",
                  "typeValidation": "strict",
                  "version": 2
                },
                "conditions": [
                  {
                    "id": "72c65611-301b-42bb-8864-8a4f8118deed",
                    "leftValue": "={{ $json.channel }}",
                    "rightValue": "email",
                    "operator": {
                      "type": "string",
                      "operation": "equals",
                      "name": "filter.operator.equals"
                    }
                  }
                ],
                "combinator": "and"
              },
              "renameOutput": true,
              "outputKey": "Email"
            }
          ]
        },
        "options": {}
      },
      "type": "n8n-nodes-base.switch",
      "typeVersion": 3.3,
      "position": [
        -176,
        432
      ],
      "id": "bc003f0a-1cbe-40a0-9000-5ac51332544d",
      "name": "Switch2"
    },
    {
      "parameters": {
        "documentId": {
          "__rl": true,
          "value": "1S8guRrH8b-z0I7axmZfagJyx9aykK8hygcI2RDn1X7E",
          "mode": "list",
          "cachedResultName": "Exceptions_Log",
          "cachedResultUrl": "https://docs.google.com/spreadsheets/d/1S8guRrH8b-z0I7axmZfagJyx9aykK8hygcI2RDn1X7E/edit?usp=drivesdk"
        },
        "sheetName": {
          "__rl": true,
          "value": "gid=0",
          "mode": "list",
          "cachedResultName": "Sheet1",
          "cachedResultUrl": "https://docs.google.com/spreadsheets/d/1S8guRrH8b-z0I7axmZfagJyx9aykK8hygcI2RDn1X7E/edit#gid=0"
        },
        "filtersUI": {
          "values": [
            {
              "lookupColumn": "review_id",
              "lookupValue": "={{ $json.review_id }}"
            }
          ]
        },
        "options": {}
      },
      "type": "n8n-nodes-base.googleSheets",
      "typeVersion": 4.7,
      "position": [
        2832,
        -496
      ],
      "id": "32279a00-a6cd-4355-ad96-793161152921",
      "name": "Read exceptions_log1",
      "credentials": {
        "googleSheetsOAuth2Api": {
          "id": "UyGfxGtg3Jm7hDky",
          "name": "Google Sheets account"
        }
      }
    },
    {
      "parameters": {
        "mode": "runOnceForEachItem",
        "jsCode": "// @ts-nocheck\nconst cmd = $json;  // from Parse Command\nconst rows = $items('Read exceptions_log2').map(i => i.json);\n\n// helper for headers with trailing spaces\nconst get = (r, k) => r[k] ?? r[k + ' '] ?? r[k.replace(/\\s+$/, '')];\n\nlet picked = null;\n\nif (cmd.review_id) {\n  picked = rows.find(r => String(get(r, 'review_id')) === String(cmd.review_id)) || null;\n} else {\n  const phone = String(cmd.approver_from || '').replace(/[^\\d]/g,'');\n  const pending = rows.filter(r =>\n    String(get(r, 'status')).toLowerCase() === 'pending' &&\n    String(get(r, 'channel')).toLowerCase() === 'whatsapp' &&\n    String(get(r, 'approver_phone') || get(r, 'approver_phone ')).replace(/[^\\d]/g,'') === phone\n  );\n  pending.sort((a,b) =>\n    (new Date(get(b,'created_at')) - new Date(get(a,'created_at'))) ||\n    ((Number(get(b,'row_number'))||0) - (Number(get(a,'row_number'))||0))\n  );\n  picked = pending[0] || null;\n}\n\nif (!picked) {\n  return { json: { ok:false, error:'No matching row found', ...cmd } };\n}\n\n// 🔥 merge, don’t overwrite\nreturn {\n  json: {\n    ...cmd,                     // keeps command, corrections, approver_from\n    __picked: true,\n    row_number: Number(get(picked,'row_number')) || null,\n    review_id: String(get(picked,'review_id') || cmd.review_id || ''),\n    row: picked\n  }\n};\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        2096,
        32
      ],
      "id": "10abf18b-76ad-4093-bc4e-03034ec09b7f",
      "name": "Pick latest row"
    },
    {
      "parameters": {
        "mode": "runOnceForEachItem",
        "jsCode": "// @ts-nocheck\nconst cmd = $json;  // from Parse Command\nconst rows = $items('Read exceptions_log2').map(i => i.json);\n\n// helper for headers with trailing spaces\nconst get = (r, k) => r[k] ?? r[k + ' '] ?? r[k.replace(/\\s+$/, '')];\n\nlet picked = null;\n\nif (cmd.review_id) {\n  picked = rows.find(r => String(get(r, 'review_id')) === String(cmd.review_id)) || null;\n} else {\n  const phone = String(cmd.approver_from || '').replace(/[^\\d]/g,'');\n  const pending = rows.filter(r =>\n    String(get(r, 'status')).toLowerCase() === 'pending' &&\n    String(get(r, 'channel')).toLowerCase() === 'whatsapp' &&\n    String(get(r, 'approver_phone') || get(r, 'approver_phone ')).replace(/[^\\d]/g,'') === phone\n  );\n  pending.sort((a,b) =>\n    (new Date(get(b,'created_at')) - new Date(get(a,'created_at'))) ||\n    ((Number(get(b,'row_number'))||0) - (Number(get(a,'row_number'))||0))\n  );\n  picked = pending[0] || null;\n}\n\nif (!picked) {\n  return { json: { ok:false, error:'No matching row found', ...cmd } };\n}\n\n// 🔥 merge, don’t overwrite\nreturn {\n  json: {\n    ...cmd,                     // keeps command, corrections, approver_from\n    __picked: true,\n    row_number: Number(get(picked,'row_number')) || null,\n    review_id: String(get(picked,'review_id') || cmd.review_id || ''),\n    row: picked\n  }\n};\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        2320,
        32
      ],
      "id": "fa899bab-e942-4089-a92b-a50fa262722c",
      "name": "Apply correction"
    },
    {
      "parameters": {
        "documentId": {
          "__rl": true,
          "value": "1S8guRrH8b-z0I7axmZfagJyx9aykK8hygcI2RDn1X7E",
          "mode": "list",
          "cachedResultName": "Exceptions_Log",
          "cachedResultUrl": "https://docs.google.com/spreadsheets/d/1S8guRrH8b-z0I7axmZfagJyx9aykK8hygcI2RDn1X7E/edit?usp=drivesdk"
        },
        "sheetName": {
          "__rl": true,
          "value": "gid=0",
          "mode": "list",
          "cachedResultName": "Sheet1",
          "cachedResultUrl": "https://docs.google.com/spreadsheets/d/1S8guRrH8b-z0I7axmZfagJyx9aykK8hygcI2RDn1X7E/edit#gid=0"
        },
        "filtersUI": {
          "values": [
            {
              "lookupColumn": "review_id",
              "lookupValue": "={{ $json.review_id }}"
            }
          ]
        },
        "options": {}
      },
      "type": "n8n-nodes-base.googleSheets",
      "typeVersion": 4.7,
      "position": [
        1008,
        -144
      ],
      "id": "8ba65a69-00ef-4435-94ea-742181a16fb9",
      "name": "Read exceptions_log2",
      "credentials": {
        "googleSheetsOAuth2Api": {
          "id": "UyGfxGtg3Jm7hDky",
          "name": "Google Sheets account"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "// @ts-nocheck\n// ---------- helpers ----------\nfunction parseKV(s) {\n  if (!s) return {};\n  const out = {};\n  String(s).split(';').forEach(pair => {\n    const [k, ...rest] = String(pair).split('=');\n    if (!k) return;\n    out[k.trim()] = rest.join('=').trim();\n  });\n  return out;\n}\nfunction unescapeHtml(s) {\n  return String(s)\n    .replace(/&quot;/g, '\"')\n    .replace(/&#39;/g, \"'\")\n    .replace(/&amp;/g, '&')\n    .replace(/&lt;/g, '<')\n    .replace(/&gt;/g, '>');\n}\nconst toNum = v => {\n  if (v === null || v === undefined || v === '') return null;\n  const n = Number(String(v).replace(/[, ]/g, ''));\n  return Number.isFinite(n) ? n : null;\n};\nconst parseTs = (s) => {\n  const t = Date.parse(s || '');\n  return Number.isFinite(t) ? t : -Infinity;\n};\n\n// ---------- pick the latest Exceptions_Log row ----------\nconst items = $input.all();          // <-- requires Mode: Run once with all items\nif (!items.length) return [];\n\nlet chosen = items[0];\nfor (const it of items.slice(1)) {\n  const aU = parseTs(chosen.json.updated_at);\n  const bU = parseTs(it.json.updated_at);\n  if (bU > aU) { chosen = it; continue; }\n\n  // tie-breaker: created_at\n  const aC = parseTs(chosen.json.created_at);\n  const bC = parseTs(it.json.created_at);\n  if (bU === aU && bC > aC) { chosen = it; continue; }\n\n  // final tie-breaker: row_number (higher = later)\n  const aR = Number(chosen.json.row_number ?? -Infinity);\n  const bR = Number(it.json.row_number ?? -Infinity);\n  if (bU === aU && bC === aC && bR > aR) chosen = it;\n}\n\nconst row = chosen.json || {};\n\n// ---------- snapshot + corrections merge (your existing logic, kept) ----------\nlet snapRaw = row.snapshot_json ?? null;\nif (typeof snapRaw === 'string') snapRaw = unescapeHtml(snapRaw);\n\n// 1) Parse snapshot safely\nlet snap = {};\ntry {\n  snap = typeof snapRaw === 'string' ? JSON.parse(snapRaw) : (snapRaw || {});\n} catch { snap = {}; }\n\n// 2) Parse corrections (JSON or \"a=b; c=d\")\nlet corr = {};\nconst corrStr = row.corrections_json || '';\ntry {\n  if (corrStr && corrStr.trim().startsWith('{')) corr = JSON.parse(corrStr);\n  else corr = parseKV(corrStr);\n} catch { corr = parseKV(corrStr); }\n\n// 3) Build base extracted\nconst FIELDS = [\n  'doc_type','doc_number','issue_date','due_date',\n  'vendor','customer','currency','subtotal','tax',\n  'shipping','total','payment_term','tax_rate','tax_type','line_items'\n];\n\nconst base = { ...(snap.extracted || {}) };\nfor (const f of FIELDS) {\n  if (base[f] === undefined || base[f] === null || base[f] === '') {\n    if (snap[f] !== undefined) base[f] = snap[f];\n    else if (snap.original?.extracted?.[f] !== undefined) base[f] = snap.original.extracted[f];\n    else if (row[f] !== undefined) base[f] = row[f];\n  }\n}\n\n// 4) Apply human corrections last\nfor (const [k, v] of Object.entries(corr)) base[k] = v;\n\n// 5) Normalize + validations\nconst subtotal  = toNum(base.subtotal) ?? 0;\nconst tax       = toNum(base.tax) ?? 0;\nconst shipping  = toNum(base.shipping) ?? 0;\nconst total     = toNum(base.total);\nconst tax_rate  = (base.tax_rate !== undefined && base.tax_rate !== null)\n  ? Number(base.tax_rate)\n  : (subtotal ? +(tax / subtotal).toFixed(4) : null);\n\nconst computed_total  = +(subtotal + tax + shipping).toFixed(2);\nconst has_doc_number  = !!(base.doc_number && String(base.doc_number).trim());\nconst has_issue_date  = !!(base.issue_date && String(base.issue_date).trim());\nconst has_subtotal    = subtotal !== null;\nconst has_total       = total !== null;\nconst has_tax         = tax !== null;\nconst has_line_items  = Array.isArray(base.line_items) && base.line_items.length > 0;\nconst total_mismatch  = has_total ? Math.abs(total - computed_total) > 0.005 : false;\nconst mismatch_amount = has_total ? +(total - computed_total).toFixed(2) : 0;\n\nconst validations = {\n  has_doc_number,\n  has_issue_date,\n  has_subtotal,\n  has_total,\n  has_tax,\n  has_line_items,\n  computed_total,\n  total_mismatch,\n  mismatch_amount,\n};\n\n// 6) Extraction metadata\nconst extraction_confidence =\n  toNum(base.extraction_confidence) ??\n  toNum(snap.extraction_confidence) ??\n  0.7;\n\nconst extraction_methods = {\n  rules_confidence:  toNum(snap?.extracted?.extraction_methods?.rules_confidence) ?? extraction_confidence,\n  llm_confidence:    toNum(snap?.extracted?.extraction_methods?.llm_confidence)   ?? 0,\n  fields_from_rules: toNum(snap?.extracted?.extraction_methods?.fields_from_rules) ?? FIELDS.length,\n  fields_from_llm:   toNum(snap?.extracted?.extraction_methods?.fields_from_llm)   ?? 0,\n};\n\n// 7) Final extracted (Ensemble-like)\nconst extracted = {\n  doc_type: (base.doc_type || 'unknown'),\n  doc_number: base.doc_number || null,\n  issue_date: base.issue_date || null,\n  due_date: base.due_date ?? null,\n  vendor: base.vendor ?? null,\n  customer: base.customer ?? null,\n  currency: base.currency || 'MYR',\n  subtotal,\n  tax,\n  tax_rate,\n  tax_type: base.tax_type ?? (tax_rate ? 'SST' : null),\n  shipping: (shipping !== null ? shipping : null),\n  total,\n  payment_term: base.payment_term ?? null,\n  line_items: Array.isArray(base.line_items) ? base.line_items : [],\n  validations,\n  extraction_confidence,\n  extraction_methods,\n};\n\n// 8) Hash key\nconst hkTotal = total !== null ? total : validations.computed_total;\nconst hash_key = `${extracted.doc_type}|${extracted.doc_number || ''}|${extracted.issue_date || ''}|${hkTotal.toFixed(2)}`;\n\n// 9) Output one item only\nconst out = {\n  review_id: row.review_id || '',\n  review_action: (row.status || 'approved').toLowerCase(),\n  corrections: corr,\n  extracted,\n  hash_key,\n  source_channel: snap.source_channel || undefined,\n  snapshot_source: 'human_review',\n};\n\nreturn out;\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        3568,
        -400
      ],
      "id": "0d202069-6848-43d4-9b03-2f1f74abcde7",
      "name": "load and extract snapshot"
    },
    {
      "parameters": {
        "operation": "send",
        "phoneNumberId": "894424953747457",
        "recipientPhoneNumber": "=601123368808",
        "textBody": "=❌ Rejected: {{$json.review_id}}.\nReason: {{$json.reason || 'N/A'}}\n",
        "additionalFields": {}
      },
      "type": "n8n-nodes-base.whatsApp",
      "typeVersion": 1.1,
      "position": [
        2544,
        176
      ],
      "id": "8f74f029-204f-4a65-8565-a253caed602f",
      "name": "Reply Rejection",
      "webhookId": "d0d02b4f-1cf8-490b-8305-7ea4e1c48806",
      "credentials": {
        "whatsAppApi": {
          "id": "JMiSrW34DEwGkuPT",
          "name": "WhatsApp account"
        }
      }
    },
    {
      "parameters": {
        "operation": "send",
        "phoneNumberId": "894424953747457",
        "recipientPhoneNumber": "={{ $('Parse Command').first().json.wa_from }}",
        "textBody": "=✅ Approved: {{$json.review_id}}. Reprocessing now.",
        "additionalFields": {}
      },
      "type": "n8n-nodes-base.whatsApp",
      "typeVersion": 1.1,
      "position": [
        3040,
        -496
      ],
      "id": "ef19d9c5-59d0-4d74-b9b8-51d945444889",
      "name": "Reply Approval",
      "webhookId": "d0d02b4f-1cf8-490b-8305-7ea4e1c48806",
      "credentials": {
        "whatsAppApi": {
          "id": "JMiSrW34DEwGkuPT",
          "name": "WhatsApp account"
        }
      }
    },
    {
      "parameters": {
        "operation": "send",
        "phoneNumberId": "894424953747457",
        "recipientPhoneNumber": "=601123368808",
        "textBody": "=✏️ Corrections received for {{$json.review_id}}. {{ JSON.stringify($json.corrections_clean) }} Reprocessing now…",
        "additionalFields": {}
      },
      "type": "n8n-nodes-base.whatsApp",
      "typeVersion": 1.1,
      "position": [
        3008,
        32
      ],
      "id": "3e70b595-54c4-4caa-b230-0d209994c14b",
      "name": "Confirm Correction",
      "webhookId": "266b3a87-51e9-4a5a-ac3e-0955073f04a0",
      "credentials": {
        "whatsAppApi": {
          "id": "JMiSrW34DEwGkuPT",
          "name": "WhatsApp account"
        }
      }
    },
    {
      "parameters": {
        "documentId": {
          "__rl": true,
          "value": "1S8guRrH8b-z0I7axmZfagJyx9aykK8hygcI2RDn1X7E",
          "mode": "list",
          "cachedResultName": "Exceptions_Log",
          "cachedResultUrl": "https://docs.google.com/spreadsheets/d/1S8guRrH8b-z0I7axmZfagJyx9aykK8hygcI2RDn1X7E/edit?usp=drivesdk"
        },
        "sheetName": {
          "__rl": true,
          "value": "gid=0",
          "mode": "list",
          "cachedResultName": "Sheet1",
          "cachedResultUrl": "https://docs.google.com/spreadsheets/d/1S8guRrH8b-z0I7axmZfagJyx9aykK8hygcI2RDn1X7E/edit#gid=0"
        },
        "filtersUI": {
          "values": [
            {
              "lookupColumn": "review_id",
              "lookupValue": "={{ $json.review_id }}"
            }
          ]
        },
        "options": {}
      },
      "type": "n8n-nodes-base.googleSheets",
      "typeVersion": 4.7,
      "position": [
        2832,
        32
      ],
      "id": "bdb57ff2-a502-42bd-968a-a19a13a6c7d0",
      "name": "Read exceptions_log3",
      "credentials": {
        "googleSheetsOAuth2Api": {
          "id": "UyGfxGtg3Jm7hDky",
          "name": "Google Sheets account"
        }
      }
    },
    {
      "parameters": {
        "documentId": {
          "__rl": true,
          "value": "1S8guRrH8b-z0I7axmZfagJyx9aykK8hygcI2RDn1X7E",
          "mode": "list",
          "cachedResultName": "Exceptions_Log",
          "cachedResultUrl": "https://docs.google.com/spreadsheets/d/1S8guRrH8b-z0I7axmZfagJyx9aykK8hygcI2RDn1X7E/edit?usp=drivesdk"
        },
        "sheetName": {
          "__rl": true,
          "value": "gid=0",
          "mode": "list",
          "cachedResultName": "Sheet1",
          "cachedResultUrl": "https://docs.google.com/spreadsheets/d/1S8guRrH8b-z0I7axmZfagJyx9aykK8hygcI2RDn1X7E/edit#gid=0"
        },
        "filtersUI": {
          "values": [
            {
              "lookupColumn": "=review_id",
              "lookupValue": "={{ $json.review_id }}"
            }
          ]
        },
        "options": {}
      },
      "type": "n8n-nodes-base.googleSheets",
      "typeVersion": 4.7,
      "position": [
        2320,
        224
      ],
      "id": "7e08e55b-4aa1-4e2c-8fed-dd2300d6c35f",
      "name": "Read exceptions_log4",
      "credentials": {
        "googleSheetsOAuth2Api": {
          "id": "UyGfxGtg3Jm7hDky",
          "name": "Google Sheets account"
        }
      }
    },
    {
      "parameters": {
        "modelId": {
          "__rl": true,
          "value": "models/gemini-2.5-flash",
          "mode": "list",
          "cachedResultName": "models/gemini-2.5-flash"
        },
        "messages": {
          "values": [
            {
              "content": "=You are a strict document classifier.\nYour task: Determine which type of business document the text represents.\n\nAllowed labels:\n[\"invoice\",\"quotation\",\"receipt\",\"credit_note\",\"delivery_order\",\"bill\",\"unknown\"]\n\nInstructions:\n- Think carefully about format, structure, and key phrases.\n- \"TAX INVOICE\" → invoice\n- \"Delivery Order\" or DO-#### → delivery_order\n- \"Official Receipt\" → receipt\n- \"Credit Note\" → credit_note\n- Quotes or proposals → quotation\n- Bills and charges → bill\n- If unsure → unknown\n\nOutput format (strictly valid JSON, minified, no explanations):\n\n{\n  \"doc_type\": \"<one_of_allowed_labels>\",\n  \"confidence\": <number 0.0-1.0>,\n  \"text\": \"<<<DOCUMENT_TEXT>>>\"\n}\n\nImportant:\n- Return the field \"text\" containing the **original document text exactly as given**, preserving real newlines and spacing (do NOT escape them, do NOT replace with \\\\n).\n- Do NOT wrap the JSON in code blocks or quotes.\n- Do NOT double-escape any characters.\n- Only output the JSON.\n\nHere is the document text:\n{{ $json.text }}\n"
            }
          ]
        },
        "simplify": false,
        "jsonOutput": true,
        "options": {}
      },
      "type": "@n8n/n8n-nodes-langchain.googleGemini",
      "typeVersion": 1,
      "position": [
        1520,
        528
      ],
      "id": "8676bf1b-8267-4b79-a6c3-7fce8c956a4b",
      "name": "LLM Classification",
      "retryOnFail": true,
      "credentials": {
        "googlePalmApi": {
          "id": "K7vMI9od1A66EdV5",
          "name": "Google Gemini(PaLM) Api account 2"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "// @ts-nocheck\n// Robust Text Handler - Handles cases where text extraction fails\n// Place this AFTER \"Extract from File\" and BEFORE classification\n\nconst items = $input.all();\n\n// Also try to get binary from Download media (WhatsApp path)\nlet binaryItems = [];\ntry {\n  binaryItems = $(\"Download media\").all();\n} catch (e) {\n  // OK if not available (Email path doesn't use it)\n}\n\nconst processedItems = items.map((item, index) => {\n  const json = item.json || {};\n  let binary = item.binary;\n  \n  // If we have binary from Download media, merge it\n  if (binaryItems.length > 0 && binaryItems[index]) {\n    binary = { ...binary, ...binaryItems[index].binary };\n  }\n  \n  // Check if we have text in various possible locations\n  let text = json.text || \n             json.data || \n             json.content || \n             json.extracted_text || \n             '';\n  \n  // If still no text, check if there's an error\n  const hasError = !!json.error;\n  const errorMessage = json.error || null;\n  \n  // Build a clean output\n  return {\n    json: {\n      // Keep important fields\n      text: text,\n      \n      // Add metadata about text extraction\n      text_extraction: {\n        success: text.length > 0,\n        length: text.length,\n        has_error: hasError,\n        error: errorMessage,\n        source_field: json.text ? 'text' : \n                     json.data ? 'data' : \n                     json.content ? 'content' : \n                     json.extracted_text ? 'extracted_text' : \n                     'none'\n      },\n      \n      // Preserve any other important fields from previous nodes\n      ...(json.from && { from: json.from }),\n      ...(json.subject && { subject: json.subject }),\n      ...(json.channel && { channel: json.channel }),\n      ...(json.sender && { sender: json.sender }),\n      ...(json.received_at && { received_at: json.received_at }),\n      \n      // Keep any metadata fields\n      ...(json.fileName && { fileName: json.fileName }),\n      ...(json.mimeType && { mimeType: json.mimeType }),\n    },\n    binary: binary\n  };\n});\n\nreturn processedItems;"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1296,
        704
      ],
      "id": "f94ebe9a-b931-476d-ba2b-bf7123f9f43a",
      "name": "Parse Extracted Output"
    },
    {
      "parameters": {
        "operation": "append",
        "documentId": {
          "__rl": true,
          "value": "1SiNQJX7YxAHiX0e3xIQxaqRmaltO4hUAYnVkn8bqtAY",
          "mode": "list",
          "cachedResultName": "AgingSnapshots",
          "cachedResultUrl": "https://docs.google.com/spreadsheets/d/1SiNQJX7YxAHiX0e3xIQxaqRmaltO4hUAYnVkn8bqtAY/edit?usp=drivesdk"
        },
        "sheetName": {
          "__rl": true,
          "value": "gid=0",
          "mode": "list",
          "cachedResultName": "Sheet1",
          "cachedResultUrl": "https://docs.google.com/spreadsheets/d/1SiNQJX7YxAHiX0e3xIQxaqRmaltO4hUAYnVkn8bqtAY/edit#gid=0"
        },
        "columns": {
          "mappingMode": "defineBelow",
          "value": {
            "snapshot_date": "={{ $json.row.snapshot_date }}",
            "direction": "={{ $json.row.direction }}",
            "doc_type": "={{ $json.row.doc_type }}",
            "doc_number": "={{ $json.row.doc_number }}",
            "party_id": "={{ $json.row.party_id }}",
            "party_name": "={{ $json.row.party_name }}",
            "issue_date": "={{ $json.row.issue_date }}",
            "due_date": "={{ $json.row.due_date }}",
            "currency": "={{ $json.row.currency }}",
            "original_total": "={{ $json.row.original_total }}",
            "amount_paid": "={{ $json.row.amount_paid }}",
            "balance_open": "={{ $json.row.balance_open }}",
            "days_outstanding": "={{ $json.row.days_outstanding }}",
            "aging_bucket": "={{ $json.row.aging_bucket }}",
            "status": "={{ $json.row.status }}"
          },
          "matchingColumns": [],
          "schema": [
            {
              "id": "snapshot_date",
              "displayName": "snapshot_date",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true
            },
            {
              "id": "direction",
              "displayName": "direction",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true
            },
            {
              "id": "doc_type",
              "displayName": "doc_type",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true
            },
            {
              "id": "doc_number",
              "displayName": "doc_number",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true
            },
            {
              "id": "party_id",
              "displayName": "party_id",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true
            },
            {
              "id": "party_name",
              "displayName": "party_name",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true
            },
            {
              "id": "issue_date",
              "displayName": "issue_date",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true
            },
            {
              "id": "due_date",
              "displayName": "due_date",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true
            },
            {
              "id": "currency",
              "displayName": "currency",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true
            },
            {
              "id": "original_total",
              "displayName": "original_total",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true
            },
            {
              "id": "amount_paid",
              "displayName": "amount_paid",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true
            },
            {
              "id": "balance_open",
              "displayName": "balance_open",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true
            },
            {
              "id": "days_outstanding",
              "displayName": "days_outstanding",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true
            },
            {
              "id": "aging_bucket",
              "displayName": "aging_bucket",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true
            },
            {
              "id": "status",
              "displayName": "status",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true
            }
          ],
          "attemptToConvertTypes": false,
          "convertFieldsToString": false
        },
        "options": {}
      },
      "type": "n8n-nodes-base.googleSheets",
      "typeVersion": 4.7,
      "position": [
        5808,
        1488
      ],
      "id": "098570e5-4cd5-4705-80e2-5cb31e3f9f0c",
      "name": "Append Aging Snapshots",
      "credentials": {
        "googleSheetsOAuth2Api": {
          "id": "UyGfxGtg3Jm7hDky",
          "name": "Google Sheets account"
        }
      }
    },
    {
      "parameters": {
        "sendTo": "mrino.work@gmail.com",
        "subject": "File Review Message",
        "emailType": "text",
        "message": "=❌ Rejected: {{$json.review_id}}.\nReason: {{$json.reason || 'N/A'}}",
        "options": {}
      },
      "type": "n8n-nodes-base.gmail",
      "typeVersion": 2.1,
      "position": [
        2544,
        336
      ],
      "id": "8f6d8c79-2ef6-4cd2-84da-169e6774a6f2",
      "name": "Rejection Message",
      "webhookId": "4bf5ea40-db5f-47cb-993d-cf3fe1661eee",
      "credentials": {
        "gmailOAuth2": {
          "id": "XiIoE1osNw89Bwp3",
          "name": "Gmail account"
        }
      }
    },
    {
      "parameters": {
        "sendTo": "mrino.work@gmail.com",
        "subject": "File Review Message",
        "emailType": "text",
        "message": "=✏️ Corrections received for {{ $('Read exceptions_log3').item.json.review_id }} Reprocessing now…",
        "options": {}
      },
      "type": "n8n-nodes-base.gmail",
      "typeVersion": 2.1,
      "position": [
        3168,
        -48
      ],
      "id": "2122bdec-2b05-49bb-9454-a44aee1652e8",
      "name": "Confirm Correction1",
      "webhookId": "4bf5ea40-db5f-47cb-993d-cf3fe1661eee",
      "credentials": {
        "gmailOAuth2": {
          "id": "XiIoE1osNw89Bwp3",
          "name": "Gmail account"
        }
      }
    },
    {
      "parameters": {
        "sendTo": "mrino.work@gmail.com",
        "subject": "File Review Message",
        "emailType": "text",
        "message": "=✅ Approved: {{$json.review_id}}. Reprocessing now.",
        "options": {}
      },
      "type": "n8n-nodes-base.gmail",
      "typeVersion": 2.1,
      "position": [
        3184,
        -496
      ],
      "id": "5f5bf3bf-32f2-4aa1-a588-e86f07c8d115",
      "name": "Reply Approval1",
      "webhookId": "4bf5ea40-db5f-47cb-993d-cf3fe1661eee",
      "credentials": {
        "gmailOAuth2": {
          "id": "XiIoE1osNw89Bwp3",
          "name": "Gmail account"
        }
      }
    }
  ],
  "pinData": {},
  "connections": {
    "WhatsApp Trigger": {
      "main": [
        [
          {
            "node": "Extract & Classify",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Extract & Classify": {
      "main": [
        [
          {
            "node": "Switch2",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Parse Command": {
      "main": [
        [
          {
            "node": "Read exceptions_log2",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Pick Row by review_id": {
      "main": [
        [
          {
            "node": "If1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "If1": {
      "main": [
        [
          {
            "node": "Switch",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Whatsapp Reply (Not Found)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Switch": {
      "main": [
        [
          {
            "node": "Update row in sheet",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Pick latest row",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Update row in sheet1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Update row in sheet": {
      "main": [
        [
          {
            "node": "Read exceptions_log1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Update row in sheet1": {
      "main": [
        [
          {
            "node": "Read exceptions_log4",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Update row in sheet2": {
      "main": [
        [
          {
            "node": "Read exceptions_log3",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Read exceptions_log": {
      "main": [
        [
          {
            "node": "load and extract snapshot",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Download media": {
      "main": [
        [
          {
            "node": "HTTP Request",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "HTTP Request": {
      "main": [
        [
          {
            "node": "If File/Image?",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Extract from File": {
      "main": [
        [
          {
            "node": "Debug Extract from File Output",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Merge": {
      "main": [
        [
          {
            "node": "Heuristic + LLM (Ensemble)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Parse gemini output": {
      "main": [
        [
          {
            "node": "Merge",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Heuristic + LLM (Ensemble)": {
      "main": [
        [
          {
            "node": "Normalize sender",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Heuristics Classification": {
      "main": [
        [
          {
            "node": "Merge",
            "type": "main",
            "index": 1
          }
        ]
      ]
    },
    "Normalize sender": {
      "main": [
        [
          {
            "node": "LLM Key Extraction",
            "type": "main",
            "index": 0
          },
          {
            "node": "Heuristics Key Extraction",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Debug Extract from File Output": {
      "main": [
        [
          {
            "node": "Parse Extracted Output",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "LLM Extraction Parser": {
      "main": [
        [
          {
            "node": "Merge Extraction",
            "type": "main",
            "index": 1
          }
        ]
      ]
    },
    "LLM Key Extraction": {
      "main": [
        [
          {
            "node": "LLM Extraction Parser",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Heuristics Key Extraction": {
      "main": [
        [
          {
            "node": "Merge Extraction",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Merge Extraction": {
      "main": [
        [
          {
            "node": "Ensemble Extraction",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Ensemble Extraction": {
      "main": [
        [
          {
            "node": "Read Mixed Docs",
            "type": "main",
            "index": 0
          },
          {
            "node": "Read Trial Balance",
            "type": "main",
            "index": 0
          },
          {
            "node": "Read Supplier Invoices",
            "type": "main",
            "index": 0
          },
          {
            "node": "Read Bank Statement",
            "type": "main",
            "index": 0
          },
          {
            "node": "Read FX Bills",
            "type": "main",
            "index": 0
          },
          {
            "node": "Read Sales Orders",
            "type": "main",
            "index": 0
          },
          {
            "node": "Build Master Data from Google Sheets",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Validation & Enrichment": {
      "main": [
        [
          {
            "node": "CSV Export Coordinator",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "CSV Export Coordinator": {
      "main": [
        [
          {
            "node": "Posting Engine (Double Entry)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Build Master Data from Google Sheets": {
      "main": [
        [
          {
            "node": "Validation & Enrichment",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Posting Engine (Double Entry)": {
      "main": [
        [
          {
            "node": "Reconciliation Engine",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Reconciliation Engine": {
      "main": [
        [
          {
            "node": "Exception Desk",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Exception Desk": {
      "main": [
        [
          {
            "node": "Flags Problem",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Review Payload": {
      "main": [
        [
          {
            "node": "Append row in sheet",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Append row in sheet": {
      "main": [
        [
          {
            "node": "Send Approval Request",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Flags Problem": {
      "main": [
        [
          {
            "node": "Review Payload",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Build Export Row",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Build Export Row": {
      "main": [
        [
          {
            "node": "Sheets Switch",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Sheets Switch": {
      "main": [
        [
          {
            "node": "Append Documents",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Append JournalEntries",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Append Customers",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Append Vendors",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Append SST",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Append Aging Snapshots",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "If File/Image?": {
      "main": [
        [
          {
            "node": "Extract from File",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Vertex A.I. extract text",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Google Gemini Chat Model": {
      "ai_languageModel": [
        [
          {
            "node": "Vertex A.I. extract text",
            "type": "ai_languageModel",
            "index": 0
          }
        ]
      ]
    },
    "Vertex A.I. extract text": {
      "main": [
        [
          {
            "node": "Parse Extracted Output",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Parse Email Attachment": {
      "main": [
        [
          {
            "node": "Extract & Classify",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Email Trigger (IMAP)": {
      "main": [
        [
          {
            "node": "Parse Email Attachment",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Switch2": {
      "main": [
        [
          {
            "node": "Parse Command",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Download media",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "If File/Image?",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Read exceptions_log1": {
      "main": [
        [
          {
            "node": "Reply Approval",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Pick latest row": {
      "main": [
        [
          {
            "node": "Apply correction",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Apply correction": {
      "main": [
        [
          {
            "node": "Update row in sheet2",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Read exceptions_log2": {
      "main": [
        [
          {
            "node": "Pick Row by review_id",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "load and extract snapshot": {
      "main": [
        [
          {
            "node": "Read Trial Balance",
            "type": "main",
            "index": 0
          },
          {
            "node": "Read Sales Orders",
            "type": "main",
            "index": 0
          },
          {
            "node": "Read Supplier Invoices",
            "type": "main",
            "index": 0
          },
          {
            "node": "Read Mixed Docs",
            "type": "main",
            "index": 0
          },
          {
            "node": "Read FX Bills",
            "type": "main",
            "index": 0
          },
          {
            "node": "Read Bank Statement",
            "type": "main",
            "index": 0
          },
          {
            "node": "Build Master Data from Google Sheets",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Reply Approval": {
      "main": [
        [
          {
            "node": "Reply Approval1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Confirm Correction": {
      "main": [
        [
          {
            "node": "Confirm Correction1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Read exceptions_log3": {
      "main": [
        [
          {
            "node": "Confirm Correction",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Read exceptions_log4": {
      "main": [
        [
          {
            "node": "Reply Rejection",
            "type": "main",
            "index": 0
          },
          {
            "node": "Rejection Message",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "LLM Classification": {
      "main": [
        [
          {
            "node": "Parse gemini output",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Parse Extracted Output": {
      "main": [
        [
          {
            "node": "Heuristics Classification",
            "type": "main",
            "index": 0
          },
          {
            "node": "LLM Classification",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Confirm Correction1": {
      "main": [
        [
          {
            "node": "Read exceptions_log",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Reply Approval1": {
      "main": [
        [
          {
            "node": "Read exceptions_log",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "active": false,
  "settings": {
    "executionOrder": "v1"
  },
  "versionId": "0e2c4127-38cb-40b4-9287-b12a75550e53",
  "meta": {
    "templateCredsSetupCompleted": true,
    "instanceId": "a0da657032afc7a3573f7e97ecf0f705ff46d73cef919a545c2620369077945d"
  },
  "id": "6IjZ3mOPaUaY4SVg",
  "tags": []
}